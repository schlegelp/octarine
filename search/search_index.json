{"config":{"lang":["en"],"separator":"[\\s\\-\\_,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>A minimalist, easy-to-use, high-performance 3D viewer. <code>Octarine</code> is build on top of the excellent <code>pygfx</code> WGPU rendering engine which does most of the heavy lifting - we're simply abstracting away some of the boiler plate code for you.</p>"},{"location":"#rationale","title":"Rationale","text":"<p>Why another 3D viewer? There are already plenty options out there: <code>vedo</code>, <code>ipygany</code>, <code>polyscope</code>, <code>napari</code>, <code>fury</code>, <code>plotly</code> or <code>pyvista</code> to name but a few. All of these are great in their own right but I wanted something (a) without heavy dependencies (i.e. no VTK), (b) that lets me interactively explore my data in both REPL and Jupyter and (c) is very performant. None of the existing solutions ticked all those boxes for me.</p> <p><code>Octarine</code> tries to fill that gap:</p> <ol> <li>Lightweight with very few direct or indirect dependencies</li> <li>Works in both Jupyter and Python shell (e.g. <code>IPython</code>)</li> <li>High performance: a mesh with 15M faces renders with 80 fps at 1080p on a 2023 MacBook Pro</li> </ol>"},{"location":"#example","title":"Example","text":"<pre><code>import octarine as oc\nimport trimesh as tm\n\n# Load an example from trimesh\nmeshes = tm.load_remote(\n    'https://github.com/mikedh/trimesh/raw/main/models/CesiumMilkTruck.glb'\n    )\n\n# Open a fresh viewer\nv = oc.Viewer()\n\n# Add mesh to viewer\nv.add(meshes)\n</code></pre>"},{"location":"#what-next","title":"What next?","text":"<ul> <li> <p> Install</p> <p>Instructions on how to install <code>Octarine</code>.</p> <p> Installation</p> </li> <li> <p> Viewer Basics</p> <p>Learn about using <code>Octarine</code> in different environments.</p> <p> The Basics</p> </li> <li> <p> Objects</p> <p>Check out the guide on different object types.</p> <p> Adding Objects</p> </li> <li> <p> Animations</p> <p>Add movement to the viewer.</p> <p> Animations</p> </li> <li> <p> Control</p> <p>Learn how to control the viewer, adjust colors, etc.</p> <p> Controls</p> </li> </ul>"},{"location":"animations/","title":"Animations","text":""},{"location":"animations/#animations","title":"Animations","text":"<p><code>octarine.Viewer</code> makes it easy to add simple animations:</p> <pre><code>&gt;&gt;&gt; import octarine as oc\n&gt;&gt;&gt; import pygfx as gfx\n\n&gt;&gt;&gt; # Generate a simple cube\n&gt;&gt;&gt; cube = gfx.Mesh(\n...     gfx.box_geometry(200, 200, 200),\n...     gfx.MeshPhongMaterial(color=\"#336699\"),\n... )\n\n&gt;&gt;&gt; # Initialize the viewer and add the cube\n&gt;&gt;&gt; v = Viewer()\n&gt;&gt;&gt; v.add(cube)\n</code></pre> <p>At this point not much is happening:</p> <p></p> <p>Next, we will use <code>octarine.Viewer.add_animation</code><code>()</code> to add a function that will rotate the cube:</p> <p></p><pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; def rotate_cube():\n...     \"\"\"Increment the rotation of the cube.\"\"\"\n...     cube.local.euler_y = (cube.local.euler_y + 0.05) % (math.pi / 2)\n\n&gt;&gt;&gt; v.add_animation(rotate_cube)\n</code></pre> <p></p> <p>So what's happening here? The <code>rotate_cube()</code> function is now being called before each frame is rendered.</p> <p>Importantly, this also means that the speed of the rotation is tied to the frame rate of our viewer. By default, the frames per second is capped at 30. Try increasing that cap and you should see the cube rotate faster:</p> <pre><code>&gt;&gt;&gt; v.max_fps = 60\n</code></pre> <p>You could decouple the rotation from the frame rate by incrementing the rotation depending on how much time has passed since the last call.</p>"},{"location":"animations/#what-next","title":"What next?","text":"<ul> <li> <p> Objects</p> <p>Check out the guide on different object types.</p> <p> Adding Objects</p> </li> <li> <p> Control</p> <p>Learn how to control the viewer, adjust colors, etc.</p> <p> Controls</p> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>This is a selection of features added, changes made and bugs fixed with each version. For a full list of changes please see the commits history on the Github repository.</p>"},{"location":"changelog/#dev","title":"dev","text":"<p>Date: ongoing</p> <p>To install the current <code>dev</code> version of <code>octarine</code>:</p> <pre><code>pip uninstall octarine3d -y\npip install git+https://github.com/schlegelp/octarine.git\n</code></pre>"},{"location":"changelog/#version-030","title":"Version <code>0.3.0</code>","text":"<p>Date: 19/03/25</p>"},{"location":"changelog/#breaking","title":"Breaking","text":"<ul> <li>drop support for Python 3.8 (follows <code>pygfx</code>)</li> </ul>"},{"location":"changelog/#improvements","title":"Improvements","text":"<ul> <li>bumps minimum version of pygfx to <code>0.9.0</code>.</li> <li>added render trigger options (see Render Triggers)</li> <li>new selection widget (see Selecting Objects)</li> <li>new transform widget (see Moving Objects)</li> <li>various improvements in the documentation</li> </ul> <p>Full Changelog: v0.2.5...v0.3.0</p>"},{"location":"changelog/#version-025","title":"Version <code>0.2.5</code>","text":"<p>Date: 31/09/24</p>"},{"location":"changelog/#fixes","title":"Fixes","text":"<ul> <li>fixed an segfault issue</li> </ul> <p>Full Changelog: v0.2.4...v0.2.5</p>"},{"location":"changelog/#version-024","title":"Version <code>0.2.4</code>","text":"<p>Date: 28/09/24</p>"},{"location":"changelog/#fixes_1","title":"Fixes","text":"<ul> <li>fix an issue when trimesh is installed without the optional scipy dependency</li> </ul> <p>Full Changelog: v0.2.3...v0.2.4</p>"},{"location":"changelog/#version-023","title":"Version <code>0.2.3</code>","text":"<p>Date: 27/09/24</p>"},{"location":"changelog/#fixes_2","title":"Fixes","text":"<ul> <li>fixes an issue with requirements</li> </ul> <p>Full Changelog: v0.2.2...v0.2.3</p>"},{"location":"changelog/#version-022","title":"Version <code>0.2.2</code>","text":"<p>Date: 27/09/24</p>"},{"location":"changelog/#improvements_1","title":"Improvements","text":"<ul> <li>existing viewers are tracked in <code>octarine.viewers</code></li> <li>allow using matplotlib-style line patterns (<code>-</code>, <code>--</code>, etc.)</li> </ul> <p>Full Changelog: v0.2.1...v0.2.2</p>"},{"location":"changelog/#version-021","title":"Version <code>0.2.1</code>","text":"<p>Date: 19/09/24</p>"},{"location":"changelog/#fixes_3","title":"Fixes","text":"<ul> <li>fixes an issue with <code>importlib-metadata</code> dependency</li> </ul> <p>Full Changelog: v0.2.0...v0.2.1</p>"},{"location":"changelog/#version-020","title":"Version <code>0.2.0</code>","text":"<p>Date: 19/09/24</p>"},{"location":"changelog/#improvements_2","title":"Improvements","text":"<ul> <li>added a basic picking system</li> <li>color picker now shows alpha channel</li> <li>general improvements to volume rendering</li> <li>use <code>Viewer.blend_mode</code> to set blend mode</li> <li><code>Viewer.set_view</code> now also accepts a dictionary with camera state</li> </ul>"},{"location":"changelog/#fixes_4","title":"Fixes","text":"<ul> <li>fixes an issue with <code>Viewer.screenshot</code></li> </ul> <p>Full Changelog: v0.1.4...v0.2.0</p>"},{"location":"changelog/#version-020_1","title":"Version &lt;<code>0.2.0</code>","text":"<p>For earlier versions, please see the commit history.</p>"},{"location":"controls/","title":"Viewer Controls","text":""},{"location":"controls/#controlling-the-viewer","title":"Controlling the Viewer","text":"<p>In The Basics, you already learned how to open a new <code>octarine.Viewer</code> and add a simple mesh, and Managing Objects showed you how to inspect and access objects on the viewer.</p> <p>Here we will demonstrate various ways to programmatically control the viewer.</p>"},{"location":"controls/#closing-the-viewer","title":"Closing the viewer","text":"<p>Use <code>octarine.Viewer.close</code><code>()</code> to close the viewer:</p> <pre><code>&gt;&gt;&gt; import octarine as oc\n&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.close()\n</code></pre>"},{"location":"controls/#adjust-size","title":"Adjust size","text":"<p>Use <code>octarine.Viewer.resize</code><code>()</code> to adjust the size of the viewer:</p> <pre><code>&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.resize((1000, 1000))\n</code></pre>"},{"location":"controls/#camera","title":"Camera","text":"<p>Use <code>octarine.Viewer.center_camera</code><code>()</code> to center the camera onto objects in the scene:</p> <pre><code>&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.center_camera()\n</code></pre> <p>Use <code>octarine.Viewer.set_view</code><code>()</code> to set the camera view:</p> <pre><code>&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.set_view('XY')  # set view to frontal\n</code></pre> <p>Found a nice view? You can save the camera state and re-apply later to get the exact same view again:</p> <pre><code>&gt;&gt;&gt; state = v.get_view()  # get the current view\n&gt;&gt;&gt; v.set_view(state)  # re-apply the view\n</code></pre>"},{"location":"controls/#colors","title":"Colors","text":"<p>Use <code>octarine.Viewer.colorize</code><code>()</code> to randomize colors:</p> <pre><code>&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.colorize(palette='seaborn:tab10')\n</code></pre> <p>Use <code>octarine.Viewer.set_colors</code><code>()</code> to set colors for given objects:</p> <pre><code>&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.add(cube, name='cube')\n&gt;&gt;&gt; v.set_colors('w')  # set color for all objects\n&gt;&gt;&gt; v.set_colors({'cube': 'r'})  # set colors for individual objects\n</code></pre> <p>Use <code>octarine.Viewer.set_bgcolor</code><code>()</code> to change the background color:</p> <pre><code>&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.set_bgcolor(\"white\")\n</code></pre>"},{"location":"controls/#hotkeys","title":"Hotkeys","text":"<p>While the viewer or widget is active you can use a set of hotkeys to control the viewer:</p> Hotkey Description <code>1</code> Set frontal (XY) view <code>2</code> Set dorsal (XZ) view <code>3</code> Set lateral (YZ) view <code>f</code> Show/hide frames per second <code>c</code> Show/hide control panel (requires PySide6) <p>You can bind custom keys using the <code>octarine.Viewer.bind_key</code><code>()</code> method:</p> <pre><code>&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; # Bind `x` key to clearing the viewer\n&gt;&gt;&gt; v.bind_key(key=\"x\", func=v.clear)\n</code></pre>"},{"location":"controls/#overlay-message","title":"Overlay message","text":"<p>Need to communicate with the user? Try the <code>octarine.Viewer.show_message</code><code>()</code>:</p> <pre><code>&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.show_message(\"Hi User!\",\n...                duration=2,  # fade out after 2s\n...                position='center')\n</code></pre> <p></p>"},{"location":"controls/#gui-controls","title":"GUI Controls","text":""},{"location":"controls/#shellipython","title":"Shell/IPython","text":"<p><code>Octarine</code> GUI controls when run from the shell currently require PySide6 to be installed and you may have to use <code>%gui qt6</code> when inside <code>IPython</code>.</p> <p>To activate them you can either press the <code>c</code> hotkey or:</p> <pre><code>&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.show_controls()\n</code></pre>"},{"location":"controls/#jupyter","title":"Jupyter","text":"<p>For GUI controls in Jupyter/lab you won't need any additional dependencies.</p> <p>To activate them you can either press the <code>c</code> hotkey or:</p> <pre><code>&gt;&gt;&gt; # Show viewer widget with `toolbar=True`\n&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.show(toolbar=True)\n\n&gt;&gt;&gt; #... or do this afterwards\n&gt;&gt;&gt; v.show_controls()\n</code></pre>"},{"location":"controls/#what-next","title":"What next?","text":"<ul> <li> <p> Objects</p> <p>Check out the guide on different object types.</p> <p> Adding Objects</p> </li> <li> <p> Animations</p> <p>Add movement to the viewer.</p> <p> Animations</p> </li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#faq","title":"FAQ","text":"<p>If you do have a question, head over to Discussion and ask away!</p> <p>In the meantime, here are a couple things that may help you troubleshoot:</p>  When trying to open the GUI controls, I get an error message like this:  <pre><code>ImportError:\n    Importing PySide6 disabled by IPython, which has\n    already imported an Incompatible QT Binding: pyqt6\n</code></pre>   This message indicates that <code>IPython</code> has started a main event loop that's incompatible with <code>PySide6</code>, the library we use to build the controls GUI.  There are two explanations: either you didn't run the right <code>%magic</code> command (or used the equivalent start-up option or config) to initialize the main event loop for <code>PySide6</code>, or you have also have <code>PyQt5</code> or (more likely) <code>PyQt6</code> installed in which case <code>IPython</code> latches on to those instead of <code>PySide6</code>.  Bottom line: make sure you only have <code>PySide6</code> installed as window manager and then run this %magic command at start-up:  <pre><code>%gui qt6\n</code></pre>  My Octarine-based app/script uses a lot of CPU.   By default, <code>octarine</code> will re-render the scene at every frame even if nothing has changed - i.e. the camera hasn't moved and objects haven't changed.  You can change the render trigger to something a bit more resource-friendly:  <ul> <li> <code>continuous</code> is the default, greedy mode </li> <li> <code>active_window</code> pauses the rendering when the window is not active </li> <li> <code>reactive</code> tries to only re-render the scene if something has changed </li> <ul> <pre><code>import octarine as oc\n\nv = oc.Viewer()\n\n# Set to render reactively\nv.render_trigger = \"reactive\"\n\n# Set to render only when window is active\nv.render_trigger = \"active_window\"\n</code></pre>  We may change the default render trigger in the future.  </ul></ul>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#installation","title":"Installation","text":"<p><code>Octarine</code> is published as a Python package and can be installed with <code>pip</code>, ideally by using a virtual environment. Open up a terminal and install <code>Octarine</code> with:</p> Full InstallMinimalDev <p>The full install should set you up for using <code>Octarine</code> in both shell (<code>IPython</code>) and Jupyter:</p> <pre><code>pip install \"octarine3d[all]\"\n</code></pre> <p>It includes <code>PySide6</code>, <code>jupyter_rfb</code> and <code>sidecar</code> as additional dependencies.</p> <p>If you opt for the minimal install, you will still have to install at least one Window Manager:</p> <pre><code>pip install octarine3d\n</code></pre> <p>To install the latest version from Github:</p> <pre><code>pip install git+https://github.com/schlegelp/octarine.git\n</code></pre> <p>Tip</p> <p>If you don't have prior experience with Python, check out Using Python's pip to Manage Your Projects' Dependencies, which is a really good introduction on the mechanics of Python package management and helps you troubleshoot if you run into errors.</p>"},{"location":"install/#window-managers","title":"Window Managers","text":"<p><code>pygfx</code> (and hence <code>Octarine</code>) requires a Window manager to work. If you have opted for the <code>[all]</code> install option, you should already have <code>PySide6</code> and <code>jupyter-rbf</code> and you don't need to worry about this.</p> <p>If instead you decided to pick your a window manager on your own, here are the ones supported by <code>wgpu-py</code>:</p> <ul> <li>qt: <code>PySide6</code>, <code>PyQt6</code>, <code>PySide2</code>, <code>PyQt5</code> all work but I recommend <code>PySide6</code> (see below)</li> <li><code>glfw</code>: a lightweight GUI for the desktop</li> <li><code>jupyter-rfb</code>: only needed if you plan on using <code>Octarine</code> in Jupyter</li> </ul> PySide6PyQt6PyQt5glfwjupyter-rbf <pre><code>pip install PySide6\n</code></pre> <pre><code>pip install PyQt6\n</code></pre> <pre><code>pip install PyQt5\n</code></pre> <pre><code>pip install glfw\n</code></pre> <pre><code>pip install jupyter-rfb\n</code></pre> <p>Please note that at this point, <code>Octarine</code>'s controls panel requires <code>PySide6</code>. So if you want GUI controls you have to use <code>PySide6</code>.</p>"},{"location":"install/#what-next","title":"What next?","text":"<ul> <li> <p> Viewer Basics</p> <p>Learn about using <code>Octarine</code> in different environments.</p> <p> The Basics</p> </li> <li> <p> Objects</p> <p>Check out the guide on different object types.</p> <p> Adding Objects</p> </li> <li> <p> Animations</p> <p>Add movement to the viewer.</p> <p> Animations</p> </li> <li> <p> Control</p> <p>Learn how to control the viewer, adjust colors, etc.</p> <p> Controls</p> </li> </ul>"},{"location":"intro/","title":"The Basics","text":""},{"location":"intro/#the-basics","title":"The Basics","text":"<p>You can use the <code>octarine.Viewer</code> in Jupyter environments, (interactive) shells such as IPython and Python scripts. The functionality is the same but the handling differs slightly.</p>"},{"location":"intro/#jupyter-labnotebook","title":"Jupyter Lab/Notebook","text":"<pre><code>import octarine as oc\nimport pygfx as gfx\n\n# Initialize a new Viewer\nv = oc.Viewer()\n\n# Make a simple cube\ncube = gfx.Mesh(\n    gfx.box_geometry(200, 200, 200),\n    gfx.MeshPhongMaterial(color=\"#336699\"),\n)\n\n# Add to viewer\nv.add(cube)\n</code></pre> <p>Important</p> <p>In Jupyter, the <code>.show()</code> method generates and displays a widget wrapping the <code>Viewer</code>. In a script/terminal, the <code>.show()</code> message will cause the window to appear. By default, the viewer is displayed right away but you can decide to belay that like so:</p> <pre><code>v = oc.Viewer(show=False)  # set show=False when initializing the viewer\n...\ndo stuff\n</code></pre> <p>Then in another cell:</p> <pre><code>v.show()\n</code></pre> <p></p> <p>Resizing the widget</p> <p>You can adjust the size of the widget either when creating the viewer via the <code>size</code> argument, or afterwards by clicking + dragging the lower right corner of the widget.</p>"},{"location":"intro/#sidecar","title":"Sidecar","text":"<p>Sidecar is a Jupyter widget that lets you put widgets such as the <code>Viewer</code> to the side of your Jupyter window.</p> <p>To install:</p> <pre><code>pip install sidecar\n</code></pre> <p>Then in the notebook:</p> <pre><code># Initialize a new Viewer\nv = oc.Viewer()\n\n# Add the cube we already made\nv.add(cube)\n\n# Show widget but put it in the sidecar\nv.show(use_sidecar=True)\n</code></pre> <p></p>"},{"location":"intro/#ipython-and-other-interactive-shells","title":"IPython and other interactive shells","text":"<p>Start IPython by running the <code>ipython</code> command from the terminal. Once you're in the Python shell:</p> <pre><code>&gt;&gt;&gt; import octarine as oc\n&gt;&gt;&gt; import pygfx as gfx\n\n&gt;&gt;&gt; # Start the main event loop for qt\n&gt;&gt;&gt; # (see below for explanation)\n&gt;&gt;&gt; %gui qt\n\n&gt;&gt;&gt; # This will immediately open an empty viewer window\n&gt;&gt;&gt; v = oc.Viewer()\n\n&gt;&gt;&gt; # Make a simple cube\n&gt;&gt;&gt; cube = gfx.Mesh(\n...     gfx.box_geometry(200, 200, 200),\n...     gfx.MeshPhongMaterial(color=\"#336699\"),\n... )\n\n&gt;&gt;&gt; # Add to viewer\n&gt;&gt;&gt; v.add(cube)\n</code></pre> <p></p> <p>The main event loop</p> <p><code>octarine.Viewer</code> will need to hook into IPython's main event loop. There are two catches here:</p> <ol> <li>You may have to start the event loop manually either via the <code>%gui</code> magic command, via start-up arguments (e.g. <code>ipython --gui qt</code>) or via config files.</li> <li>The active main event loop has to be compatible with the <code>pygfx</code> backend you're using. At this point, the safest bet is to use <code>%gui qt</code>.</li> </ol> <p><code>octarine</code> is mainly tested with IPython but there are of course other interactive REPLs out there such as e.g. <code>ptpython</code>. To use <code>octarine</code> interactively, you may have to figure out how to start the (correct) event loop yourself. For example. in case of <code>ptpython</code> you need to start it with a <code>--asyncio</code> flag:</p> <pre><code>$ ptpython --asyncio\n</code></pre>"},{"location":"intro/#scripts-non-interactive-shell","title":"Scripts &amp; non-interactive shell","text":"<p>You can also use <code>octarine</code> in Python scripts or from non-interactive shells (like the default <code>python</code> shell). In those scenarios you will have to additionally start the event loop:</p> <pre><code>import octarine as oc\n\n# Initialize the viewer but don't show yet as that would start blocking\nv = oc.Viewer(show=False)\n\n# Add random points as scatter\nimport numpy as np\npoints = np.random.rand(10, 3)  # 10 random points\nv.add(points)\n\n# Show and start the event loop in one go\nv.show(start_loop=True)\n</code></pre>"},{"location":"intro/#offscreen","title":"Offscreen","text":"<p>What if you just want to take a quick snapshot without bothering with a window/widget? No problem:</p> <pre><code>import octarine as oc\n\n# Open a fresh offscreen viewer (this will not spawn a window)\nv = oc.Viewer(offscreen=True)\n\n# Add a mesh to viewer\n# (reusing the cube from examples above)\nv.add(cube)\n\n# Adjust camera view to frontal\nv.set_view('XY')\n\n# Take a snapshot\nv.screenshot('cube.png', alpha=True)\n</code></pre> <p></p> <p>Keeping track of your Viewer(s)</p> <p>What if you forget to assign your viewer to a variable?</p> <pre><code>&gt;&gt;&gt; oc.Viewer()\n</code></pre> <p>Easy! <code>Octarine</code> tracks all instantiated viewers for you:</p> <pre><code>&gt;&gt;&gt; oc.viewers\n[&lt;octarine.viewer.Viewer at 0x138a74310&gt;]\n&gt;&gt;&gt; v = oc.viewers[0]\n</code></pre>"},{"location":"intro/#what-next","title":"What next?","text":"<ul> <li> <p> Objects</p> <p>Check out the guide on different object types.</p> <p> Adding Objects</p> </li> <li> <p> Animations</p> <p>Add movement to the viewer.</p> <p> Animations</p> </li> <li> <p> Control</p> <p>Learn how to control the viewer, adjust colors, etc.</p> <p> Controls</p> </li> </ul>"},{"location":"manage/","title":"Managing Objects","text":""},{"location":"manage/#managing-objects","title":"Managing objects","text":""},{"location":"manage/#accessing-objects","title":"Accessing objects","text":"<p>As you add objects to the octarine.Viewer, you might want to keep track of them so you can e.g. colorize or remove them at a later point.</p> <p>Unless specified, each object gets a generic identifier:</p> <pre><code>&gt;&gt;&gt; duck = tm.load_remote(\n...         'https://github.com/mikedh/trimesh/raw/main/models/Duck.glb'\n...     )\n\n&gt;&gt;&gt; # Add the duck\n&gt;&gt;&gt; v.add_mesh(duck)\n</code></pre> <p></p> <p>Let's check what objects are there:</p> <pre><code>&gt;&gt;&gt; v.objects\nOrderedDict([('Object', [&lt;pygfx.Mesh at 0x37f4f8b90&gt;])])\n</code></pre> <p>The <code>.objects</code> property will return a dictionary mapping IDs to <code>pygfx</code> visuals.</p> <p>Alternatively, you can also do this:</p> <pre><code>&gt;&gt;&gt; v['Object']\n[&lt;pygfx.Mesh at 0x37f4f8b90&gt;]\n</code></pre> <p>Instead of generic IDs, we can also explicitly set the ID:</p> <pre><code>&gt;&gt;&gt; v.add_mesh(duck, name='Duck')\n&gt;&gt;&gt; v.objects\nOrderedDict([('Duck', [&lt;pygfx.Mesh at 0x37f5f8a12&gt;])])\n</code></pre> <p>This can also be used to combine multiple objects under the same ID.</p>"},{"location":"manage/#modifying-objects","title":"Modifying objects","text":"<p>Why are the object IDs discussed above relevant? Well, they help you manipulate objects after they've been added:</p> <pre><code>&gt;&gt;&gt; v.set_colors({'Duck': 'w'})\n&gt;&gt;&gt; v.hide_objects('Duck')\n&gt;&gt;&gt; v.remove_objects('Duck')\n</code></pre>"},{"location":"manage/#moving-objects-interactively","title":"Moving objects interactively","text":"<p>You can designate a single object to be moved interactively:</p> <pre><code>&gt;&gt;&gt; v.moveable_object = \"Duck\"\n</code></pre> <p></p> <p>To remove the transform widget again simple do:</p> <pre><code>&gt;&gt;&gt; v.moveable_object = None\n</code></pre>"},{"location":"manage/#what-next","title":"What next?","text":"<ul> <li> <p> Objects</p> <p>Manipulate viewer and objects (color, size, visibility, etc).</p> <p> Viewer Controls</p> </li> <li> <p> Selection</p> <p>Selecting objects on the viewer.</p> <p> Selection</p> </li> </ul>"},{"location":"objects/","title":"Adding Objects","text":""},{"location":"objects/#adding-objects-to-the-viewer","title":"Adding Objects to the Viewer","text":"<p>Off the bat <code>Octarine</code> supports 4 types of objects, all of which have dedicated <code>Viewer</code> methods:</p> Object Type Viewer method 1. Meshes octarine.Viewer.add_mesh 2. Points octarine.Viewer.add_points 3. Lines octarine.Viewer.add_lines 4. Image Volumes octarine.Viewer.add_volume <p>As a general entry point you can use the octarine.Viewer.add<code>()</code> method which will pass an object to the respective specialized function:</p> <pre><code>&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; # This ...\n&gt;&gt;&gt; v.add(mesh)\n&gt;&gt;&gt; # ... is effectively the same as this\n&gt;&gt;&gt; v.add_mesh(mesh)\n</code></pre> <p>Tip</p> <p>The specialised methods may offer more ways to customize the visual.</p>"},{"location":"objects/#meshes","title":"Meshes","text":"<p><code>Octarine</code> will happily work with anything that's mesh-like - i.e. anything that has <code>.vertices</code> and <code>.faces</code>. In practice, I'd recommend you use <code>trimesh</code> to e.g. load meshes from files:</p> <pre><code>&gt;&gt;&gt; import octarine as oc\n&gt;&gt;&gt; import trimesh as tm\n\n&gt;&gt;&gt; mesh = tm.load_remote(\n...         'https://github.com/mikedh/trimesh/raw/main/models/bunny.ply'\n...     )\n&gt;&gt;&gt; type(mesh)\n&lt;trimesh.Trimesh(vertices.shape=(8146, 3), faces.shape=(16301, 3), name=`bunny.ply`)\n\n&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.add_mesh(mesh, name='bunny')\n</code></pre> <p></p> <p>See octarine.Viewer.add_mesh<code>()</code> for details!</p>"},{"location":"objects/#points","title":"Points","text":"<p>Points are expected to be 2d <code>(N, 3)</code> numpy arrays:</p> <pre><code>&gt;&gt;&gt; import octarine as oc\n&gt;&gt;&gt; v = oc.Viewer()\n\n&gt;&gt;&gt; # Add random points as scatter\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; points = np.random.rand(10, 3)  # 10 random points\n&gt;&gt;&gt; v.add_points(points color='r')\n</code></pre> <p></p> <p>See octarine.Viewer.add_points<code>()</code> for details!</p>"},{"location":"objects/#lines","title":"Lines","text":"<p>Lines are expected to be either a <code>(N, 3)</code> numpy array representing a single contiguous line or a list thereof:</p> <pre><code>&gt;&gt;&gt; import octarine as oc\n&gt;&gt;&gt; v = oc.Viewer()\n\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; line1 = np.random.rand(10, 3)  # points for line 1\n&gt;&gt;&gt; line2 = np.random.rand(5, 3)  # points for line 2\n&gt;&gt;&gt; v.add_lines([line1, line2], color='y')\n</code></pre> <p></p> <p>See octarine.Viewer.add_lines<code>()</code> for details!</p>"},{"location":"objects/#image-volumes","title":"Image Volumes","text":"<p>Image volumes are expected to be 3d <code>numpy</code> arrays or <code>trimesh.VoxelGrids</code>.</p> <p>In this example, we're using pynrrd to read an image stack of a Drosophila brain downloaded from figshare (link):</p> <pre><code>&gt;&gt;&gt; import nrrd\n&gt;&gt;&gt; vol, meta = nrrd.read('JRC2018_UNISEX_38um_iso_16bit.nrrd')\n&gt;&gt;&gt; # Dimensions along each axis are 0.38 microns\n&gt;&gt;&gt; meta['sizes]\narray([[0.38, 0.  , 0.  ],\n       [0.  , 0.38, 0.  ],\n       [0.  , 0.  , 0.38]])\n\n&gt;&gt;&gt; import octarine as oc\n&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.add_volume(vol, spacing=(.38, .38, .38))\n&gt;&gt;&gt; v.show_bounds = True\n</code></pre> <p></p> <p>Note that the default blend mode for the renderer may cause objects behind or inside the volume to look funny. You can change the blend mode by setting e.g. <code>v.set_alpha_mode('add')</code>.</p> <p>Alternatively, you can also add slices through the volume:</p> <pre><code>&gt;&gt;&gt; import cmap\n&gt;&gt;&gt; v.add_volume(\n...     vol,\n...     color=cmap.Colormap('Greys'),  # use a different colormap\n...     spacing=.38,  # single value for isometric data\n...     slice=True  # can also be a tuple, e.g. (True, False, True)\n... )\n</code></pre> <p></p> <p>See octarine.Viewer.add_volume<code>()</code> for details!</p>"},{"location":"objects/#custom-objects","title":"Custom Objects","text":"<p>What if you have want to visualize something not currently supported by <code>Octarine</code>?</p> <p>Go check out the Extending Octarine tutorial to learn how!</p>"},{"location":"objects/#what-next","title":"What next?","text":"<ul> <li> <p> Animations</p> <p>Add movement to the viewer.</p> <p> Animations</p> </li> <li> <p> Control</p> <p>Learn how to control the viewer, adjust colors, etc.</p> <p> Controls</p> </li> </ul>"},{"location":"selections/","title":"Selecting Objects","text":""},{"location":"selections/#selecting-objects","title":"Selecting objects","text":"<p>This section will demonstrate how to select objects in your viewer. <code>Octarine</code> offers two options:</p> <ol> <li>\"Picking\" by clicking on individual objects</li> <li>Drawing a selection rectangle to select objects</li> </ol>"},{"location":"selections/#picking","title":"Picking","text":"<p><code>Octarine</code> wraps <code>pygfx</code>'s basic picking system. This allows you to easily select objects by double clicking on them:</p> <pre><code>v = oc.Viewer()\n\n# Make 3 cubes that are slightly offset against each other\nimport pygfx as gfx\nfor i in range(3):\n    color = ['red', 'green', 'blue'][i]\n    cube = gfx.Mesh(\n        gfx.box_geometry(200, 200, 200),\n        gfx.MeshPhongMaterial(color=color),\n    )\n    cube.local.x = 300 * i\n    v.add(cube, name=f\"{color} cube\")\n\n# Tell viewer to select objects on double click\nv.on_double_click = \"select\"\n</code></pre> <p>See the help for <code>v.on_double_click</code> for other presets.</p> <p>Selection color</p> <p>You can change the color used to highlight selected objects:</p> <pre><code>v.highlight_color = \"purple\"\n</code></pre> <p>Alternatively, you can also adjust the behavior when hovering over objects:</p> <pre><code># Highlight objects when hovering over them\nv.on_hover = \"highlight\"\n</code></pre> <p>If you want a custom behaviour, have a look at the logic behind the <code>Viewer.on_double_click</code> setter - <code>pygfx</code> makes it ridiculously easy to hook into the event system. We're also happy to extend the current list of options - please open a Github Issue if you have suggestions!</p> <p>Last but not least, these setting can also be accessed through the control panel:</p> <p></p>"},{"location":"selections/#drawing-selections","title":"Drawing Selections","text":"<p>In this section you will learn to hook up a selection widget to a viewer to make more complex selections.</p> <p>We'll start by importing <code>octarine</code> and the <code>SelectionGizmo</code>:</p> <pre><code>import octarine as oc\nfrom octarine.selection import SelectionGizmo\n</code></pre> <p>Next, we will instantiate the viewer and add a few cubes:</p> <pre><code>v = oc.Viewer()\n\n# Make 3 cubes that are slightly offset against each other\nimport pygfx as gfx\nfor i in range(3):\n    color = ['red', 'green', 'blue'][i]\n    cube = gfx.Mesh(\n        gfx.box_geometry(200, 200, 200),\n        gfx.MeshPhongMaterial(color=color),\n    )\n    cube.local.x = 300 * i\n    v.add(cube, name=f\"{color} cube\")\n</code></pre> <p></p> <p>Note that we have given our cubes some useful names: </p><pre><code>&gt;&gt;&gt; v.objects\nOrderedDict([('red cube', [&lt;pygfx.Mesh  at 0x3565dca10&gt;]),\n             ('green cube', [&lt;pygfx.Mesh  at 0x356441f10&gt;]),\n             ('blue cube', [&lt;pygfx.Mesh  at 0x14ef4c450&gt;])])\n</code></pre><p></p> <p>Next, we will add a <code>SelectionGizmo</code> to the viewer:</p> <pre><code># Instantiate the gizmo and link it to our viewer\nsel = SelectionGizmo(viewer=v)\n</code></pre> <p>Now if you hold <code>Shift</code> and click &amp; drag on the viewer, you should see a selection rectangle being drawn:</p> <p></p> <p>Other than that nothing happens. That's because we haven't told the <code>SelectionGizmo</code> what do do once a selection has been made. For that, we need to attach a callback function that accepts a dictionary describing the selection. Let's write a little function that just prints the content of that dictionary and attach as callback:</p> <pre><code>from pprint import pprint\n\ndef print_selection(sel_dict):\n    pprint(\"Selection made:\")\n    pprint(sel_dict)\n\nsel.add_callback(print_selection)\n</code></pre> <p>Now if we make a selection, you should see something like this in your console:</p> <pre><code>'Selection made:'\n{'blue cube': {'clipped': False,\n               'contained': False,\n               'objects': [{'clipped': False,\n                            'contained': False,\n                            'data': None}]},\n 'green cube': {'clipped': True,\n                'contained': False,\n                'objects': [{'clipped': True,\n                             'contained': False,\n                             'data': array([False, False, False, False, True, True, True, True, True, False, True, False, False, True, False, True, True, False, True, False, False, True, False, True])}]},\n 'red cube': {'clipped': True,\n              'contained': True,\n              'objects': [{'clipped': True, 'contained': True, 'data': None}]}}\n</code></pre> <p>If you look closely, you will see that the selection rectangle:</p> <ol> <li>missed the blue cube</li> <li>clipped the green cube</li> <li>fully contained the red cube</li> </ol> <p>For the clipped green cube, the dictionary gives us an array (<code>data</code>) that tells us which vertices of the cube were in- (<code>True</code>) and which were outside (<code>False</code>) of the selection box.</p> <p>Let's do something more elaborate and add a callback that highlight cubes that we selected:</p> <pre><code>def highlight_selection(sel_dict):\n    # First unhighlight all currently highlighted objects\n    v.unhighlight_objects()\n\n    # Now highlight the selected neurons\n    v.highlight_objects([ob for ob, props in sel_dict.items() if props['clipped'] is True])\n\nsel.add_callback(highlight_selection)\n</code></pre> <p></p>"},{"location":"triggers/","title":"Render Triggers","text":""},{"location":"triggers/#render-triggers","title":"Render triggers","text":"<p>This vignette will teach you about render triggers and how to make your viewer more efficient.</p> <p>To illustrate the principle, let's generate this scene:</p> <pre><code>import octarine as oc\n\nviewer = oc.Viewer()\n\n# Make 3 cubes that are slightly offset against each other\nimport pygfx as gfx\nfor i in range(3):\n    color = ['red', 'green', 'blue'][i]\n    cube = gfx.Mesh(\n        gfx.box_geometry(200, 200, 200),\n        gfx.MeshPhongMaterial(color=color),\n    )\n    cube.local.x = 300 * i\n    viewer.add(cube, name=f\"{color} cube\")\n</code></pre> <p></p> <p>If you now open your Activity Monitor (OSX), Task Manager (Windows) or whatever your system uses and isolate the Python process, you may notice that it uses a fair amount of CPU and GPU even though nothing much is happening:</p> <p></p> <p>Note</p> <p>It's possible that the CPU/GPU usage goes down if the viewer is minimized or covered by other windows.</p> <p>That's because the <code>octarine.Viewer</code> continuously renders new frames up to the maximum frame rate (30 FPS by default). You can decrease the maximum frame rate by setting <code>viewer.max_fps = 15</code> but that will make interacting with the viewer less smooth.</p> <p>A better solution is to change the render trigger from <code>continous</code> to <code>reactive</code>:</p> <pre><code>viewer.render_trigger = \"reactive\"\n</code></pre> <p>This tells the viewer to only trigger rendering of a new frame if the scene has actually changed - for example when the camera has moved or you added a new object. As a consequence, you should see your CPU/GPU load go down to almost zero when not interacting with the viewer:</p> <p></p> <p>Important: Reactive rendering has a few caveats! Because we're not greedily rendering new frames whenever we get the chance, we have to rely on a complex-ish system of signals that tell our <code>Viewer</code> when things have changed and it's time to compute a new frame. Basic actions will correctly trigger a re-render but if you encounter a situation where the viewer should update but doesn't, please open an issue on Github!</p> <p>Also, if you are running e.g. custom animations outside of the <code>Viewer.add_animations</code> hook you may have to manually tell the viewer to re-render by setting <code>viewer._render_stale = True</code>.</p> <p>Active window</p> <p>There is a third option, <code>active_window</code>, which pauses rendering when the Window isn't active. However, this currently only works if you are using the PySide6 backend.</p>"},{"location":"api/selection/","title":"Selection","text":""},{"location":"api/selection/#selectiongizmo","title":"SelectionGizmo","text":""},{"location":"api/selection/#octarine.selection.SelectionGizmo","title":"<code>octarine.selection.SelectionGizmo</code>","text":"<p>Selection gizmo for the 3D viewer.</p> <p>This gizmo allows to select objects in the 3d viewer by drawing a rectangle.</p> PARAMETER DESCRIPTION <code>viewer</code> <p>The viewer to which the gizmo is attached.</p> <p> TYPE: <code>Viewer</code> </p> <code>callback</code> <p>A function to call when the selection is done. Must accept the selection as a dictionary (see [<code>SelectionGizmo._find_selected_objects</code>][octarine.selection.SelectionGizmo._find_selected_objects] for details). Can also be added post-hoc using `SelectionGizmo.add_callback().</p> <p> TYPE: <code>callable</code> DEFAULT: <code>None</code> </p> <code>ignore_invisible</code> <p>Whether to ignore invisible objects. Default is True.</p> <p> TYPE: <code> bool</code> DEFAULT: <code>True</code> </p> <code>**kwargs</code> <p>Keyword arguments passed to BaseSelectionGizmo.</p> <p> DEFAULT: <code>{}</code> </p> Source code in <code>octarine/selection.py</code> <pre><code>class SelectionGizmo:\n    \"\"\"Selection gizmo for the 3D viewer.\n\n    This gizmo allows to select objects in the 3d viewer by drawing a rectangle.\n\n    Parameters\n    ----------\n    viewer : Viewer\n        The viewer to which the gizmo is attached.\n    callback : callable, optional\n        A function to call when the selection is done. Must accept the selection as a dictionary (see\n        [`SelectionGizmo._find_selected_objects`][octarine.selection.SelectionGizmo._find_selected_objects]\n        for details). Can also be added post-hoc using `SelectionGizmo.add_callback().\n    ignore_invisible :  bool\n        Whether to ignore invisible objects. Default is True.\n    **kwargs\n        Keyword arguments passed to BaseSelectionGizmo.\n\n    \"\"\"\n\n    def __init__(self, viewer, callback=None, ignore_invisible=True, **kwargs):\n        self.callbacks = []\n        if not isinstance(callback, type(None)):\n            self.add_callback(callback)\n\n        if \"callback_after\" in kwargs:\n            raise ValueError(\n                \"The `callback_after` keyword argument is reserved for internal use!\"\n            )\n        kwargs[\"callback_after\"] = self.handle_post_selection\n        self.gizmo = BaseSelectionGizmo(viewer=viewer, **kwargs)\n        self.ignore_invisible = ignore_invisible\n\n    def add_callback(self, callback):\n        if not callable(callback):\n            raise ValueError(\"`callback` must be a single callable\")\n        self.callbacks.append(callback)\n\n    def handle_post_selection(self, gizmo):\n        \"\"\"Handle things after selection.\"\"\"\n        # If no callback is set, we're done here\n        if not self.callbacks and not self.gizmo._debug:\n            return\n\n        # Find the selected objects\n        selection = self.find_selected_objects()\n        if self.gizmo._debug:\n            n_clipped = len([k for k in selection if selection[k][\"clipped\"]])\n            n_contained = len([k for k in selection if selection[k][\"contained\"]])\n            print(f\"Selected objects: {n_clipped} clipped, {n_contained} contained:\")\n            print(selection)\n\n        # Run the callbacks\n        for func in self.callbacks:\n            func(selection)\n\n    def find_selected_objects(self):\n        \"\"\"Find objects that are selected by the selection box.\n\n        Notes\n        -----\n        - currently only Meshes and Points are supported; other objects are returns as `None`\n\n        Returns\n        -------\n        dict\n                Returns a dictionary matching `Viewer.objects`, i.e. keyed by object groups:\n\n                    {\n                        \"group_name\": {\n                            \"clipped\": bool,  # whether the object(s) is at least clipped\n                            \"contained\": bool,  # whether the object(s) is fully contained\n                            \"objects\": [  # an entry for each object in the object group\n                                {\n                                \"clipped\": bool,\n                                \"contained\": bool,\n                                \"data\": np.ndarray | None (if not clipped or fully contained)\n                                }, ...\n                            ]\n                        }\n                    }\n\n        \"\"\"\n        # If no selection box, return right away\n        if not self.gizmo._sel_info:\n            return {}\n\n        # Next, we need to iterate over all objects, (1) project their data to screen space\n        # and (2) determine whether they are inside the selection box\n        selection = {}\n        for name in (\n            self.gizmo._viewer.visible\n            if self.ignore_invisible\n            else self.gizmo._viewer.objects\n        ):\n            selection[name] = {\"clipped\": False, \"contained\": True, \"objects\": []}\n            objects = self.gizmo._viewer.objects[name]\n            for ob in objects:\n                # Extract the data depending on the type of object\n                if not isinstance(ob, (gfx.Mesh, gfx.Points, gfx.Line)):\n                    # Note to self: we could use object boundaries where no data is available\n                    if self.gizmo._debug:\n                        print(f\"Object {ob} not supported\")\n                    selection[name][\"contained\"] = None\n                    selection[name][\"objects\"].append(\n                        {\"clipped\": None, \"contained\": None, \"data\": None}\n                    )\n                    continue\n\n                # Get the data representing the object\n                data = ob.geometry.positions.data\n\n                # Apply world transform\n                data = la.vec_transform(data, ob.world.matrix)\n\n                # Project the data to screen space\n                # (N.B. were using the viewer's normal camera, not the overlay's NDC camera)\n                data_screen = la.vec_transform(\n                    data, self.gizmo._viewer.camera.camera_matrix\n                )\n\n                # Check whether the object is in the selection box\n                mask = self.is_data_in_selection_box(data_screen)\n\n                # Store the results\n                is_clipped = bool(np.any(mask))  # avoid getting np.True_/np.False_\n\n                if isinstance(ob, gfx.Line):\n                    # Lines can have breaks where the data will be `nan` - these will\n                    # always count as not inside the selection box. We need to ignore\n                    # these when checking for full containment.\n                    data_not_nan = np.all(~np.isnan(data), axis=1)\n                    is_contained = bool(np.all(mask[data_not_nan]))\n                else:\n                    is_contained = bool(np.all(mask))\n\n                # If the object is either fully contained or fully outside, we don't\n                # really need to pass the mask\n                if is_contained or not is_clipped:\n                    mask = None\n\n                selection[name][\"objects\"].append(\n                    {\"clipped\": is_clipped, \"contained\": is_contained, \"data\": mask}\n                )\n                # Propagate results to parent group\n                if not is_contained:\n                    selection[name][\"contained\"] = False\n                if is_clipped:\n                    selection[name][\"clipped\"] = True\n\n        return selection\n\n    def is_data_in_selection_box(self, data_screen):\n        \"\"\"Check whether selected obejct is inside selection box.\n\n        Parameters\n        ----------\n        data_screen : (N, 3) array\n            The data in screen coordinates.\n\n        Returns\n        -------\n        bool\n            Whether the object is inside the selection box.\n\n        \"\"\"\n        if not self.gizmo._sel_info:\n            return np.zeros(data_screen.shape[0], dtype=bool)\n\n        # Check whether the object is in the selection box\n        return np.all(\n            (data_screen[:, [0, 1]] &gt;= self.gizmo.bounds[0, :-1])\n            &amp; (data_screen[:, [0, 1]] &lt;= self.gizmo.bounds[1, :-1]),\n            axis=1,\n        )\n</code></pre>"},{"location":"api/selection/#octarine.selection.SelectionGizmo.find_selected_objects","title":"<code>find_selected_objects()</code>","text":"<p>Find objects that are selected by the selection box.</p> Notes <ul> <li>currently only Meshes and Points are supported; other objects are returns as <code>None</code></li> </ul> RETURNS DESCRIPTION <code>dict</code> <p>Returns a dictionary matching <code>Viewer.objects</code>, i.e. keyed by object groups:</p> <pre><code>{\n    \"group_name\": {\n        \"clipped\": bool,  # whether the object(s) is at least clipped\n        \"contained\": bool,  # whether the object(s) is fully contained\n        \"objects\": [  # an entry for each object in the object group\n            {\n            \"clipped\": bool,\n            \"contained\": bool,\n            \"data\": np.ndarray | None (if not clipped or fully contained)\n            }, ...\n        ]\n    }\n}\n</code></pre> Source code in <code>octarine/selection.py</code> <pre><code>def find_selected_objects(self):\n    \"\"\"Find objects that are selected by the selection box.\n\n    Notes\n    -----\n    - currently only Meshes and Points are supported; other objects are returns as `None`\n\n    Returns\n    -------\n    dict\n            Returns a dictionary matching `Viewer.objects`, i.e. keyed by object groups:\n\n                {\n                    \"group_name\": {\n                        \"clipped\": bool,  # whether the object(s) is at least clipped\n                        \"contained\": bool,  # whether the object(s) is fully contained\n                        \"objects\": [  # an entry for each object in the object group\n                            {\n                            \"clipped\": bool,\n                            \"contained\": bool,\n                            \"data\": np.ndarray | None (if not clipped or fully contained)\n                            }, ...\n                        ]\n                    }\n                }\n\n    \"\"\"\n    # If no selection box, return right away\n    if not self.gizmo._sel_info:\n        return {}\n\n    # Next, we need to iterate over all objects, (1) project their data to screen space\n    # and (2) determine whether they are inside the selection box\n    selection = {}\n    for name in (\n        self.gizmo._viewer.visible\n        if self.ignore_invisible\n        else self.gizmo._viewer.objects\n    ):\n        selection[name] = {\"clipped\": False, \"contained\": True, \"objects\": []}\n        objects = self.gizmo._viewer.objects[name]\n        for ob in objects:\n            # Extract the data depending on the type of object\n            if not isinstance(ob, (gfx.Mesh, gfx.Points, gfx.Line)):\n                # Note to self: we could use object boundaries where no data is available\n                if self.gizmo._debug:\n                    print(f\"Object {ob} not supported\")\n                selection[name][\"contained\"] = None\n                selection[name][\"objects\"].append(\n                    {\"clipped\": None, \"contained\": None, \"data\": None}\n                )\n                continue\n\n            # Get the data representing the object\n            data = ob.geometry.positions.data\n\n            # Apply world transform\n            data = la.vec_transform(data, ob.world.matrix)\n\n            # Project the data to screen space\n            # (N.B. were using the viewer's normal camera, not the overlay's NDC camera)\n            data_screen = la.vec_transform(\n                data, self.gizmo._viewer.camera.camera_matrix\n            )\n\n            # Check whether the object is in the selection box\n            mask = self.is_data_in_selection_box(data_screen)\n\n            # Store the results\n            is_clipped = bool(np.any(mask))  # avoid getting np.True_/np.False_\n\n            if isinstance(ob, gfx.Line):\n                # Lines can have breaks where the data will be `nan` - these will\n                # always count as not inside the selection box. We need to ignore\n                # these when checking for full containment.\n                data_not_nan = np.all(~np.isnan(data), axis=1)\n                is_contained = bool(np.all(mask[data_not_nan]))\n            else:\n                is_contained = bool(np.all(mask))\n\n            # If the object is either fully contained or fully outside, we don't\n            # really need to pass the mask\n            if is_contained or not is_clipped:\n                mask = None\n\n            selection[name][\"objects\"].append(\n                {\"clipped\": is_clipped, \"contained\": is_contained, \"data\": mask}\n            )\n            # Propagate results to parent group\n            if not is_contained:\n                selection[name][\"contained\"] = False\n            if is_clipped:\n                selection[name][\"clipped\"] = True\n\n    return selection\n</code></pre>"},{"location":"api/selection/#octarine.selection.SelectionGizmo.handle_post_selection","title":"<code>handle_post_selection(gizmo)</code>","text":"<p>Handle things after selection.</p> Source code in <code>octarine/selection.py</code> <pre><code>def handle_post_selection(self, gizmo):\n    \"\"\"Handle things after selection.\"\"\"\n    # If no callback is set, we're done here\n    if not self.callbacks and not self.gizmo._debug:\n        return\n\n    # Find the selected objects\n    selection = self.find_selected_objects()\n    if self.gizmo._debug:\n        n_clipped = len([k for k in selection if selection[k][\"clipped\"]])\n        n_contained = len([k for k in selection if selection[k][\"contained\"]])\n        print(f\"Selected objects: {n_clipped} clipped, {n_contained} contained:\")\n        print(selection)\n\n    # Run the callbacks\n    for func in self.callbacks:\n        func(selection)\n</code></pre>"},{"location":"api/selection/#octarine.selection.SelectionGizmo.is_data_in_selection_box","title":"<code>is_data_in_selection_box(data_screen)</code>","text":"<p>Check whether selected obejct is inside selection box.</p> PARAMETER DESCRIPTION <code>data_screen</code> <p>The data in screen coordinates.</p> <p> TYPE: <code>(N, 3) array</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the object is inside the selection box.</p> Source code in <code>octarine/selection.py</code> <pre><code>def is_data_in_selection_box(self, data_screen):\n    \"\"\"Check whether selected obejct is inside selection box.\n\n    Parameters\n    ----------\n    data_screen : (N, 3) array\n        The data in screen coordinates.\n\n    Returns\n    -------\n    bool\n        Whether the object is inside the selection box.\n\n    \"\"\"\n    if not self.gizmo._sel_info:\n        return np.zeros(data_screen.shape[0], dtype=bool)\n\n    # Check whether the object is in the selection box\n    return np.all(\n        (data_screen[:, [0, 1]] &gt;= self.gizmo.bounds[0, :-1])\n        &amp; (data_screen[:, [0, 1]] &lt;= self.gizmo.bounds[1, :-1]),\n        axis=1,\n    )\n</code></pre>"},{"location":"api/utils/","title":"Utility","text":""},{"location":"api/utils/#utility","title":"Utility","text":""},{"location":"api/utils/#octarine.register_converter","title":"<code>octarine.register_converter(t, converter, insert='first')</code>","text":"<p>Register a converter for a given data type.</p> PARAMETER DESCRIPTION <code>t</code> <pre><code>    Data type the converter is meant to convert. If a function\n    it is expected to take a single argument `x` and return\n    True if `x` can be converted using `converter` and False\n    if not.\n</code></pre> <p> TYPE: <code>        type | hashable | callable</code> </p> <code>converter</code> <pre><code>    Function that converts `x` to pygfx visuals. Must accept\n    at least a single argument and return either a single\n    visual or a list thereof.\n</code></pre> <p> TYPE: <code>callable</code> </p> <code>insert</code> <pre><code>    Whether to insert the converter at the beginning or end\n    of the list of converters. This is important because when\n    looking for a converter for a given type we will use the\n    first one that matches.\n</code></pre> <p> TYPE: <code>   \"first\" | \"last\"</code> DEFAULT: <code>'first'</code> </p> Source code in <code>octarine/conversion.py</code> <pre><code>def register_converter(t, converter, insert='first'):\n    \"\"\"Register a converter for a given data type.\n\n    Parameters\n    ----------\n    t :         type | hashable | callable\n                Data type the converter is meant to convert. If a function\n                it is expected to take a single argument `x` and return\n                True if `x` can be converted using `converter` and False\n                if not.\n    converter : callable\n                Function that converts `x` to pygfx visuals. Must accept\n                at least a single argument and return either a single\n                visual or a list thereof.\n    insert :    \"first\" | \"last\"\n                Whether to insert the converter at the beginning or end\n                of the list of converters. This is important because when\n                looking for a converter for a given type we will use the\n                first one that matches.\n\n    \"\"\"\n    global CONVERTERS\n    assert insert in ('first', 'last')\n\n    if not callable(converter):\n        raise ValueError(\"Converter must be callable.\")\n\n    if not callable(t) and not is_hashable(t):\n        raise ValueError(\"Type must be hashable or callable.\")\n\n\n    if insert == 'first':\n        items = list(CONVERTERS.items())\n        items.insert(0, (t, converter))\n        CONVERTERS = dict(items)\n    else:\n        CONVERTERS[t] = converter\n</code></pre>"},{"location":"api/viewer/","title":"Viewer","text":""},{"location":"api/viewer/#octarineviewer","title":"octarine.Viewer","text":""},{"location":"api/viewer/#octarine.Viewer","title":"<code>octarine.Viewer</code>","text":"<p>PyGFX 3D viewer.</p> PARAMETER DESCRIPTION <code>offscreen</code> <pre><code>    If True, will use an offscreen Canvas. Useful if you only\n    want a screenshot.\n</code></pre> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>title</code> <pre><code>    Title of the viewer window.\n</code></pre> <p> TYPE: <code>    str</code> DEFAULT: <code>'Octarine Viewer'</code> </p> <code>max_fps</code> <pre><code>    Maximum frames per second to render.\n</code></pre> <p> TYPE: <code>  int</code> DEFAULT: <code>30</code> </p> <code>size</code> <pre><code>    Size of the viewer window.\n</code></pre> <p> TYPE: <code>     tuple</code> DEFAULT: <code>None</code> </p> <code>camera</code> <pre><code>    Type of camera to use. Defaults to \"ortho\". Note you can always\n    change the camera type by adjust the `Viewer.camera.fov` attribute\n    (0 = ortho, &gt;0 = perspective).\n</code></pre> <p> TYPE: <code>   \"ortho\" | \"perspective\"</code> DEFAULT: <code>'ortho'</code> </p> <code>control</code> <pre><code>    Controller type to use. Defaults to \"trackball\".\n</code></pre> <p> TYPE: <code>  \"trackball\" | \"panzoom\" | \"fly\" | \"orbit\"</code> DEFAULT: <code>'trackball'</code> </p> <code>show</code> <pre><code>    Whether to immediately show the viewer. When set to \"auto\" (default),\n    will immmediately show the viewer if:\n     - we are in a Jupyter environment\n     - we are in an iPython session and we can hook into an iPython event loop\n    If neither of the above applies or `show=False`, you will have to manually run\n    `Viewer.show()`. This gives you the chance to add objects to the viewer\n    before it is shown and the blocking event loop is started.\n    The `show` parameter is ignored if `offscreen` is True.\n</code></pre> <p> TYPE: <code>     \"auto\" (default) | bool</code> DEFAULT: <code>True</code> </p> <code>**kwargs</code> <pre><code>    Keyword arguments are passed through to ``WgpuCanvas``.\n</code></pre> <p> DEFAULT: <code>{}</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>class Viewer:\n    \"\"\"PyGFX 3D viewer.\n\n    Parameters\n    ----------\n    offscreen : bool\n                If True, will use an offscreen Canvas. Useful if you only\n                want a screenshot.\n    title :     str\n                Title of the viewer window.\n    max_fps :   int\n                Maximum frames per second to render.\n    size :      tuple, optional\n                Size of the viewer window.\n    camera :    \"ortho\" | \"perspective\"\n                Type of camera to use. Defaults to \"ortho\". Note you can always\n                change the camera type by adjust the `Viewer.camera.fov` attribute\n                (0 = ortho, &gt;0 = perspective).\n    control :   \"trackball\" | \"panzoom\" | \"fly\" | \"orbit\"\n                Controller type to use. Defaults to \"trackball\".\n    show :      \"auto\" (default) | bool\n                Whether to immediately show the viewer. When set to \"auto\" (default),\n                will immmediately show the viewer if:\n                 - we are in a Jupyter environment\n                 - we are in an iPython session and we can hook into an iPython event loop\n                If neither of the above applies or `show=False`, you will have to manually run\n                `Viewer.show()`. This gives you the chance to add objects to the viewer\n                before it is shown and the blocking event loop is started.\n                The `show` parameter is ignored if `offscreen` is True.\n    **kwargs\n                Keyword arguments are passed through to ``WgpuCanvas``.\n\n    \"\"\"\n\n    # Palette used for assigning colors to objects\n    palette = \"seaborn:tab10\"\n    highlight_color = \"yellow\"\n\n    def __init__(\n        self,\n        offscreen=False,\n        title=\"Octarine Viewer\",\n        max_fps=30,\n        camera=\"ortho\",\n        control=\"trackball\",\n        size=None,\n        show=True,\n        **kwargs,\n    ):\n        # We need to import WgpuCanvas before we (potentially) start the event loop\n        # If we don't we get a segfault.\n        if not offscreen:\n            from rendercanvas.auto import RenderCanvas\n\n        # Check if we're running in an IPython environment\n        if utils._type_of_script() == \"ipython\" and not offscreen:\n            ip = get_ipython()  # noqa: F821\n            if not ip.active_eventloop:\n                if AUTOSTART_EVENT_LOOP:\n                    try:\n                        ip.enable_gui(\"qt6\")\n                        logger.debug(\n                            \"Looks like you're running in an IPython environment but haven't \"\n                            \"started a GUI event loop. We've started one for you using the \"\n                            \"Qt6 backend.\"\n                        )\n                    except (ModuleNotFoundError, ImportError):\n                        raise ValueError(\n                            \"Looks like you're running in an IPython environment but haven't \"\n                            \"started a GUI event loop. We tried to start one for you using the \"\n                            \"Qt6 backend (via %gui qt6) but that failed. You may have to start \"\n                            \"the event loop manually. See \"\n                            \"https://ipython.readthedocs.io/en/stable/config/eventloops.html\"\n                            \"for details.\"\n                        )\n                else:\n                    raise ValueError(\n                        'IPython event loop not running. Please use e.g. \"%gui qt6\" to hook into the event loop.'\n                    )\n\n        self._title = title\n\n        # Update some defaults as necessary\n        defaults = {\"title\": title, \"max_fps\": max_fps}\n        if size is not None:\n            defaults[\"size\"] = size\n        defaults.update(kwargs)\n\n        # If we're running in headless mode (primarily for tests on CI) we will\n        # simply not initialize the gfx objects. Not ideal but it turns\n        # out to be very annoying to correctly setup on Github Actions.\n        if getattr(config, \"HEADLESS\", False):\n            return\n\n        if not offscreen:\n            self.canvas = RenderCanvas(**defaults)\n        else:\n            self.canvas = OffscreenRenderCanvas(**defaults)\n\n        # There is a bug in pygfx 0.1.18 that causes the renderer to crash\n        # when using a Jupyter canvas without explicitly setting the pixel_ratio.\n        # This is already fixed in main but for now:\n        if self._is_jupyter:\n            self.renderer = gfx.renderers.WgpuRenderer(\n                self.canvas, show_fps=False, pixel_ratio=2\n            )\n        else:\n            self.renderer = gfx.renderers.WgpuRenderer(self.canvas, show_fps=False)\n\n        # Set up a default scene\n        self.scene = gfx.Scene()\n\n        # A minor ambient light\n        self.scene.add(gfx.AmbientLight(intensity=0.5))\n\n        # A strong point light form front/top/left\n        self.scene.add(gfx.PointLight(intensity=4))\n        self.scene.children[-1].shadow.bias = 0.0000005  # this helps with shadow acne\n        self.scene.children[-1].local.x = -1000000  # move to the left\n        self.scene.children[-1].local.y = -1000000  # move up\n        self.scene.children[-1].local.z = -1000000  # move light forward\n\n        # A weaker point light from the back\n        self.scene.add(gfx.PointLight(intensity=1))\n        self.scene.children[-1].shadow.bias = 0.0000005  # this helps with shadow acne\n        self.scene.children[-1].local.x = 1000000  # move to the left\n        self.scene.children[-1].local.y = 1000000  # move up\n        self.scene.children[-1].local.z = 1000000  # move light forward\n\n        # Set up a default background\n        self._background = gfx.Background(None, gfx.BackgroundMaterial((0, 0, 0)))\n        self.scene.add(self._background)\n\n        # Add camera\n        if camera == \"ortho\":\n            self.camera = gfx.OrthographicCamera()\n        elif camera == \"perspective\":\n            self.camera = gfx.PerspectiveCamera()\n        else:\n            raise ValueError(f\"Unknown camera type: {camera}\")\n\n        # Add controller\n        controller = {\n            \"trackball\": gfx.TrackballController,\n            \"panzoom\": gfx.PanZoomController,\n            \"fly\": gfx.FlyController,\n            \"orbit\": gfx.OrbitController,\n        }.get(control, None)\n        if controller is None:\n            raise ValueError(f\"Unknown controller type: {control}\")\n\n        self.controller = controller(self.camera, register_events=self.renderer)\n\n        # Setup overlay\n        self.overlay_camera = gfx.NDCCamera()\n        self.overlay_scene = gfx.Scene()\n\n        # Setup transform gizmo\n        self.transform_gizmo = None\n\n        # Stats\n        self.stats = gfx.Stats(self.renderer)\n        self._show_fps = False\n\n        # Setup key events\n        self._key_events = {}\n        self._key_events[\"1\"] = lambda: self.set_view(\"XY\")  # frontal view\n        self._key_events[\"2\"] = lambda: self.set_view(\"XZ\")  # lateral view\n        self._key_events[\"3\"] = lambda: self.set_view(\"YZ\")  # top view\n        self._key_events[(\"1\", (\"Shift\",))] = lambda: self.set_view(\"-XY\")  # back view\n        self._key_events[(\"2\", (\"Shift\",))] = lambda: self.set_view(\n            \"-XZ\"\n        )  # other lateral view\n        self._key_events[(\"3\", (\"Shift\",))] = lambda: self.set_view(\n            \"-YZ\"\n        )  # bottom view\n        self._key_events[\"f\"] = lambda: self._toggle_fps()\n        self._key_events[\"c\"] = lambda: self._toggle_controls()\n\n        def _keydown(event):\n            \"\"\"Handle key presses.\"\"\"\n            if not event.modifiers:\n                if event.key in self._key_events:\n                    self._key_events[event.key]()\n            else:\n                tup = (event.key, tuple(event.modifiers))\n                if tup in self._key_events:\n                    self._key_events[tup]()\n\n        # Register events\n        self.renderer.add_event_handler(_keydown, \"key_down\")\n\n        # Finally, setting some variables\n        self._show_bounds = False\n        self._shadows = False\n        self._animations = {}\n        self._animations_flagged_for_removal = []\n        self._animations_frame_counter = 0\n        self._on_double_click = None\n        self._on_hover = None\n        self._objects_pickable = False\n        self._selected = []\n        self._render_trigger = \"continuous\"\n\n        viewers.append(self)\n\n        # This starts the animation loop\n        if show and not self._is_jupyter:\n            self.show(start_loop=show == \"start_loop\")\n\n    def _animate(self):\n        \"\"\"Run the rendering loop.\"\"\"\n        rm = self.render_trigger\n\n        # First run the user animations\n        self._animations_frame_counter += 1\n        if self._animations_frame_counter == sys.maxsize:  # reset to avoid overflow\n            self._animations_frame_counter = 0\n        # N.B. we're iterating over the list because the user might add / remove\n        # animations during the loop\n        for i, (func, (on_error, run_every, req_render)) in enumerate(\n            list(self._animations.items())\n        ):\n            # Skip if we're not supposed to run this frame\n            if run_every and (self._animations_frame_counter % run_every) != 0:\n                continue\n            try:\n                func()\n                if req_render:\n                    self._render_stale = True\n            except BaseException as e:\n                if on_error == \"raise\":\n                    raise e\n                elif on_error == \"remove\":\n                    logger.error(\n                        f\"Removing animation function '{func}' because of error: {e}\"\n                    )\n                    # Flag animation for removal\n                    self._animations_flagged_for_removal.append(i)\n\n        # Check if any animations need to be removed\n        for f in self._animations_flagged_for_removal[::-1]:\n            self._animations.pop(f)\n        self._animations_flagged_for_removal = []\n\n        # Now check if we need to render the scene\n        if rm == \"active_window\":\n            # Note to self: we need to explore how to do this with different backends / Window managers\n            # Not sure if this will work with e.g. Jupyter (does it know when the notebook is active?)\n            if hasattr(self.canvas, \"isActiveWindow\"):\n                if not self.canvas.isActiveWindow():\n                    self.canvas.request_draw()\n                    return\n        elif rm == \"reactive\":\n            # If the scene is not stale, we can skip rendering\n            if not getattr(self, \"_render_stale\", False):\n                self.canvas.request_draw()\n                return\n\n        # Now render the scene\n        if self._show_fps:\n            with self.stats:\n                self.renderer.render(self.scene, self.camera, flush=False)\n                if self.transform_gizmo:\n                    self.renderer.render(self.transform_gizmo, self.camera, flush=False)\n                self.renderer.render(\n                    self.overlay_scene, self.overlay_camera, flush=False\n                )\n            self.stats.render()\n        else:\n            self.renderer.render(self.scene, self.camera, flush=False)\n            if self.transform_gizmo:\n                self.renderer.render(self.transform_gizmo, self.camera, flush=False)\n            self.renderer.render(self.overlay_scene, self.overlay_camera)\n\n        # Set stale to False\n        self._render_stale = False\n\n        self.canvas.request_draw()\n\n    def _next_color(self):\n        \"\"\"Return next color in the colormap.\"\"\"\n        # Cache the full palette. N.B. that ordering of colors in cmap depends on\n        # the number of colors requested - i.e. we can't just grab the last color.\n        if not hasattr(self, \"_cached_palette\") or self.palette != self._cached_palette:\n            self._cached_colors = list(cmap.Colormap(self.palette).iter_colors())\n            self._cached_palette = self.palette\n\n        if not hasattr(self, \"_palette_index\"):\n            self._palette_index = -1\n        self._palette_index += 1\n\n        return self._cached_colors[self._palette_index % len(self._cached_colors)]\n\n    def _next_label(self, prefix=\"Object\"):\n        \"\"\"Return next label.\"\"\"\n        existing = [o for o in self.objects if str(o).startswith(prefix)]\n        if len(existing) == 0:\n            return prefix\n        return f\"{prefix}.{len(existing) + 1:03}\"\n\n    def __getitem__(self, key):\n        \"\"\"Get item.\"\"\"\n        return self.objects[key]\n\n    def __contains__(self, key):\n        \"\"\"Check if object is on canvas.\"\"\"\n        return key in self.objects\n\n    def __len__(self):\n        \"\"\"Return number of objects on canvas.\"\"\"\n        return len(self._object_ids)\n\n    @property\n    def blend_mode(self):\n        \"\"\"Deprecated! Render blend mode.\n\n        This property has been deprecated. Please use `Viewer.set_alpha_mode()` instead.\n\n        \"\"\"\n        raise DeprecationWarning(\n            \"The 'blend_mode' property is deprecated. Please use 'Viewer.set_alpha_mode()' instead.\"\n        )\n\n    @property\n    def render_trigger(self):\n        \"\"\"Determines when the scene is (re)rendered.\n\n        By default, we leave it to the renderer to decide when to render the scene.\n        You can adjust that behaviour by setting render mode to:\n         - \"continuous\" (default): leave it to the renderer to decide when to render the scene\n         - \"reactive\": rendering is only triggered when the scene changes\n         - \"active_window\": rendering is only done when the window is active; this currently\n           only works with the PySide backend\n\n        \"\"\"\n        return self._render_trigger\n\n    @render_trigger.setter\n    def render_trigger(self, mode):\n        valid = (\"continuous\", \"active_window\", \"reactive\")\n        if mode not in valid:\n            raise ValueError(f\"Unknown render mode: {mode}. Must be one of {valid}.\")\n\n        # No need to do anything if the value is the same\n        if mode == getattr(self, \"_render_trigger\", None):\n            return\n\n        # Add/remove event handlers as necessary\n        if mode == \"reactive\":\n            self._set_stale_func = lambda event: setattr(self, \"_render_stale\", True)\n            self.renderer.add_event_handler(\n                self._set_stale_func,\n                \"pointer_down\",\n                \"pointer_move\",\n                \"pointer_up\",\n                \"wheel\",\n                # \"before_render\",\n            )\n        elif self._render_trigger == \"reactive\":\n            self.renderer.remove_event_handler(\n                self._set_stale_func,\n                \"pointer_down\",\n                \"pointer_move\",\n                \"pointer_up\",\n                \"wheel\",\n                # \"before_render\",\n            )\n\n        self._render_trigger = mode\n\n    @property\n    def controls(self):\n        \"\"\"Return the controls widget.\"\"\"\n        return getattr(self, \"_controls\", None)\n\n    @property\n    def visible(self):\n        \"\"\"List IDs of currently visible objects.\"\"\"\n        objects = self.objects  # grab this only once to speed things up\n        return [s for s in objects if objects[s][0].visible]\n\n    @property\n    def invisible(self):\n        \"\"\"List IDs of currently visible objects.\"\"\"\n        objects = self.objects  # grab this only once to speed things up\n        return [s for s in objects if not objects[s][0].visible]\n\n    @property\n    def pinned(self):\n        \"\"\"List IDs of currently pinned objects.\"\"\"\n        objects = self.objects  # grab this only once to speed things up\n        return [s for s in objects if getattr(objects[s][0], \"_pinned\", False)]\n\n    @property\n    def selected(self):\n        \"\"\"Return IDs of or set selected objects.\"\"\"\n        return self._selected\n\n    @selected.setter\n    def selected(self, val):\n        val = utils.make_iterable(val) if val is not None else []\n\n        objects = self.objects  # grab once to speed things up\n        logger.debug(f\"{len(val)} objects selected ({len(self.selected)} previously)\")\n        # First un-highlight neurons which aren't selected anymore\n        for s in [s for s in self._selected if s not in val]:\n            for v in objects[s]:\n                v.material.color = v._stored_color\n\n        # Highlight new additions\n        for s in val:\n            if s not in self._selected:\n                for v in objects[s]:\n                    # Keep track of old colour\n                    v._stored_color = v.material.color\n                    v.material.color = gfx.Color(self.highlight_color)\n        self._selected = list(val)\n\n        # Update legend and set render stale (if applicable)\n        update_helper(self, legend=True, bounds=False)\n\n    @property\n    def size(self):\n        \"\"\"Return size of the canvas.\"\"\"\n        return self.canvas.get_logical_size()\n\n    @size.setter\n    def size(self, size):\n        \"\"\"Set size of the canvas.\"\"\"\n        assert len(size) == 2\n        self.canvas.set_logical_size(*size)\n\n    @property\n    def shadows(self):\n        \"\"\"Return shadow state.\"\"\"\n        return self._shadows\n\n    @shadows.setter\n    def shadows(self, v):\n        \"\"\"Set shadow state.\"\"\"\n        if not isinstance(v, bool):\n            raise TypeError(f\"Expected bool, got {type(v)}\")\n\n        def set_shadow(obj, state):\n            if hasattr(obj, \"cast_shadow\"):\n                obj.cast_shadow = state\n            if hasattr(obj, \"receive_shadow\"):\n                obj.receive_shadow = state\n\n        if v != self._shadows:\n            self._shadows = v\n            for vis in self.visuals:\n                set_shadow(vis, v)\n\n            for ch in self.scene.children:\n                if isinstance(ch, gfx.PointLight):\n                    ch.cast_shadow = v\n\n            # self.scene.traverse(lambda x: set_shadow(x, v))\n\n    @property\n    def visuals(self):\n        \"\"\"List of all visuals on this canvas.\"\"\"\n        return [c for c in self.scene.children if hasattr(c, \"_object_id\")]\n\n    @property\n    def bounds(self):\n        \"\"\"Bounds of all currently visuals (visible and invisible).\"\"\"\n        bounds = []\n        for vis in self.visuals:\n            # Skip the bounding box itself\n            if getattr(vis, \"_object_id\", \"\") == \"boundingbox\":\n                continue\n\n            try:\n                bounds.append(vis._bounds)\n            except BaseException:\n                pass\n\n        if not bounds:\n            return None\n\n        bounds = np.dstack(bounds)\n\n        mn = bounds[:, 0, :].min(axis=1)\n        mx = bounds[:, 1, :].max(axis=1)\n\n        return np.vstack((mn, mx)).T\n\n    @property\n    def max_fps(self):\n        \"\"\"Maximum frames per second to render.\"\"\"\n        return self.canvas._subwidget._BaseRenderCanvas__scheduler._max_fps\n\n    @max_fps.setter\n    def max_fps(self, v):\n        assert isinstance(v, int)\n        self.canvas._subwidget._BaseRenderCanvas__scheduler._max_fps = v\n\n    @property\n    def moveable_object(self):\n        \"\"\"Get/Set the object that can be moved via the transform gizmo.\"\"\"\n        if self.transform_gizmo is None:\n            return None\n        return self.transform_gizmo._object_to_control\n\n    @moveable_object.setter\n    def moveable_object(self, obj):\n        if obj is None:\n            if self.transform_gizmo:\n                self.transform_gizmo._object_to_control = None\n            return\n\n        if isinstance(obj, str):\n            if obj not in self.objects:\n                raise ValueError(f\"Object '{obj}' not found.\")\n            elif len(self.objects[obj]) &gt; 1:\n                raise ValueError(f\"Object '{obj}' consists of multiple WorldObjects.\")\n            obj = self.objects[obj][0]\n        elif not isinstance(obj, gfx.WorldObject):\n            raise TypeError(f\"Expected pygfx object, got {type(obj)}\")\n\n        if self.transform_gizmo is None:\n            # The transform gizmo is rendered independent of the scene (so it always stay on top)\n            self.transform_gizmo = gfx.TransformGizmo(obj)\n            self.transform_gizmo.add_default_event_handlers(self.renderer, self.camera)\n        else:\n            self.transform_gizmo._object_to_control = obj\n\n    @property\n    def _is_jupyter(self):\n        \"\"\"Check if Viewer is using Jupyter canvas.\"\"\"\n        return \"JupyterWgpuCanvas\" in str(type(self.canvas))\n\n    @property\n    def _is_offscreen(self):\n        \"\"\"Check if Viewer is using offscreen canvas.\"\"\"\n        return isinstance(self.canvas, OffscreenRenderCanvas)\n\n    @property\n    def _window_manager(self):\n        \"\"\"Which window manager is being used.\"\"\"\n        try:\n            return type(self.canvas).__module__.split(\".\")[-1]\n        except BaseException:\n            return \"na\"\n\n    @property\n    def _object_ids(self):\n        \"\"\"All object IDs on this canvas in order of addition.\"\"\"\n        obj_ids = []\n        for v in self.visuals:\n            if hasattr(v, \"_object_id\"):\n                obj_ids.append(v._object_id)\n        return sorted(set(obj_ids), key=lambda x: obj_ids.index(x))\n\n    @property\n    def objects(self):\n        return self._objects()\n\n    @lru_cache(maxsize=1)\n    def _objects(self):\n        \"\"\"Ordered dictionary {name-&gt;[visuals]} of all objects in order of addition.\"\"\"\n        objects = OrderedDict()\n        for v in self.visuals:\n            if hasattr(v, \"_object_id\"):\n                if v._object_id in objects:\n                    objects[v._object_id].append(v)\n                else:\n                    objects[v._object_id] = [v]\n\n        return objects\n\n    @property\n    def objects_pickable(self):\n        return self._objects_pickable\n\n    @objects_pickable.setter\n    def objects_pickable(self, v):\n        if not isinstance(v, bool):\n            raise TypeError(f\"Expected bool, got {type(v)}\")\n\n        # No need to do anything if the value is the same\n        if v == self._objects_pickable:\n            return\n\n        self._objects_pickable = v\n\n        # Set pick_write to new value for all materials\n        for objects in self.objects.values():\n            for ob in objects:\n                try:\n                    ob.material.pick_write = v\n                except AttributeError:\n                    pass\n\n    @property\n    def highlighted(self):\n        \"\"\"Return IDs of currently highlighted objects.\"\"\"\n        highlighted = []\n        for obj in self.objects:\n            if any([getattr(v, \"_highlighted\", False) for v in self.objects[obj]]):\n                highlighted.append(obj)\n        return highlighted\n\n    @property\n    def on_hover(self):\n        \"\"\"Determines what to do when hovering over objects.\n\n        Can be set to:\n         - `None`: do nothing\n         - \"highlight\": hide object\n\n        \"\"\"\n        return self._on_hover\n\n    @on_hover.setter\n    def on_hover(self, v):\n        valid = (None, \"highlight\")\n        if v not in valid:\n            raise ValueError(\n                f\"Unknown value for on_hover: {v}. Must be one of {valid}.\"\n            )\n\n        # No need to do anything if the value is the same\n        if v == self._on_hover:\n            return\n\n        if v:\n            # Make objects pickable\n            self.objects_pickable = True\n\n            # Add the event handler\n            self.scene.add_event_handler(self._highlight_on_hover_event, \"pointer_move\")\n        else:\n            self.scene.remove_event_handler(\n                self._highlight_on_hover_event, \"pointer_move\"\n            )\n            current_hover = getattr(self, \"_current_hover_object\", None)\n\n            # Make sure to unhighlight the current hover object\n            if current_hover:\n                self.unhighlight_objects(current_hover)\n                self._current_hover_object = None\n\n        self._on_hover = v\n\n    def _highlight_on_hover_event(self, event):\n        \"\"\"This is the event callback for highlighting objects on hover.\"\"\"\n        # If any buttons are pressed (e.g. mouse left during panning) ignore the event\n        if event.buttons:\n            return\n\n        # Parse the current object\n        new_hover = event.pick_info[\"world_object\"]\n        current_hover = getattr(self, \"_current_hover_object\", None)\n\n        # Break early if there is nothing to do\n        if new_hover is None and current_hover is None:\n            # print(\"  No hover\")\n            return\n\n        new_hover_id = [k for k, v in self.objects.items() if new_hover in v]\n        new_hover_id = new_hover_id[0] if new_hover_id else None\n\n        # See if we need to de-highlight the current hover object\n        if current_hover:\n            # If the new object is the same as the current one, we don't need to do anything\n            if current_hover == new_hover_id:\n                return\n            if current_hover in self.objects:\n                self.unhighlight_objects(current_hover)\n            self._current_hover_object = None\n\n        # Highlight the new object\n        if new_hover_id:\n            self.highlight_objects(\n                new_hover_id, color=getattr(self, \"_highlight_on_hover_color\", 0.2)\n            )\n            self._current_hover_object = new_hover_id\n\n    @property\n    def on_double_click(self):\n        \"\"\"Determines what to do when double clicking on objects.\n\n        Can be set to:\n         - `None`: do nothing\n         - \"hide\": hide object\n         - \"remove\": remove object\n         - \"select\": select object\n\n        \"\"\"\n        return self._on_double_click\n\n    @on_double_click.setter\n    def on_double_click(self, v):\n        valid = (None, \"hide\", \"remove\", \"select\")\n        if v not in valid:\n            raise ValueError(\n                f\"Unknown value for on_double_click: {v}. Must be one of {valid}.\"\n            )\n\n        # No need to do anything if the value is the same\n        if v == self._on_double_click:\n            return\n\n        # First try to remove the current event handler for double clicks\n        try:\n            self.scene.remove_event_handler(\n                getattr(self, \"_on_double_click_func\", None), \"double_click\"\n            )\n        except KeyError:\n            pass\n\n        if v:\n            # Make objects pickable\n            self.objects_pickable = True\n\n            # Now add the new event handler\n            func = partial(handle_object_event, viewer=self, actions=(v,))\n            self.scene.add_event_handler(func, \"double_click\")\n            self.__on_double_click_func = func\n\n        self._on_double_click = v\n\n    def add_animation(self, x, on_error=\"remove\", run_every=None, req_render=True):\n        \"\"\"Add animation function to the Viewer.\n\n        Parameters\n        ----------\n        x :         callable\n                    Function to add to the animation loop.\n        on_error :  \"remove\" | \"ignore\" | \"raise\"\n                    What to do if the function throws an error. If \"remove\",\n                    the function will be removed from the animation loop. If\n                    \"ignore\", the error will be ignored and the function will\n                    continue to be called.\n        run_every : int, optional\n                    Use to run the function every n frames.\n        req_render : bool, optional\n                    Whether this animation requires a re-render of the scene.\n                    This is mainly a flag to help the viewer to decide\n                    whether/when to trigger a render. See also the `render_trigger`\n                    property.\n\n        \"\"\"\n        if not callable(x):\n            raise TypeError(f\"Expected callable, got {type(x)}\")\n\n        assert on_error in [\"remove\", \"ignore\", \"raise\"]\n\n        self._animations[x] = (on_error, run_every, req_render)\n\n    def remove_animation(self, x):\n        \"\"\"Remove animation function from the Viewer.\n\n        Parameters\n        ----------\n        x :     callable | int\n                Either the function itself or its index\n                in the list of animations.\n\n        \"\"\"\n        if callable(x):\n            self._animations_flagged_for_removal.append(x)\n        elif isinstance(x, int):\n            self._animations_flagged_for_removal.append(\n                list(self._animations.keys())[x]\n            )\n        else:\n            raise TypeError(f\"Expected callable or index (int), got {type(x)}\")\n\n    def add_effect(self, effect, **kwargs):\n        \"\"\"Add post-processing effect to the renderer.\n\n        You can also use this method to adjust the parameters of an existing effect.\n\n        Parameters\n        ----------\n        effect :   str\n                    Name of the effect to add. Currently supported:\n                     - \"edl\" (Eye-Dome Lighting)\n                       This effect enhances depth perception for complex\n                       geometries by darkening edges based on depth differences.\n\n        **kwargs\n                    Keyword arguments passed to the effect constructor:\n                    - edl:\n                      - strength (default 5): EDL strength; ypical range ~ [0.5, 10.0].\n                      - radius (default 1.5): sampling radius in pixels\n                      - depth_edge_threshold (default 0.0)\n\n        \"\"\"\n        effect = EFFECT_CLASSES.get(effect, None)\n        if effect is None:\n            raise ValueError(f\"Unknown effect: {effect}\")\n\n        # Check if we already have this effect\n        p = None\n        for e in self.renderer.effect_passes:\n            if isinstance(e, effect):\n                p = e\n                break\n\n        if p is None:\n            # Overwrite the default of 1 (seems too weak in my hands)\n            if (effect is EDLPass) and \"strength\" not in kwargs:\n                kwargs[\"strength\"] = 5.0\n\n            p = effect(**kwargs)\n            self.renderer.effect_passes = tuple(list(self.renderer.effect_passes) + [p])\n        else:\n            # Update parameters\n            for k, v in kwargs.items():\n                if hasattr(p, k):\n                    setattr(p, k, v)\n                else:\n                    raise ValueError(f\"Effect '{effect}' has no parameter '{k}'\")\n\n    def show(self, use_sidecar=False, toolbar=False, start_loop=False):\n        \"\"\"Show viewer.\n\n        Parameters\n        ----------\n\n        For Jupyter lab only:\n\n        use_sidecar : bool\n                      If True, will use the Sidecar extension to display the\n                      viewer outside the notebooks. Will throw an error if\n                      Sidecar is not installed.\n        toolbar :     bool\n                      If True, will show a toolbar. You can always show/hide\n                      the toolbar with ``viewer.show_controls()`` and\n                      ``viewer.hide_controls()``, or the `c` hotkey.\n\n        For scripts &amp; standard REPL:\n\n        start_loop :  bool\n                      If True, will start the blocking (!) event loop. This is\n                      the recommended way to show the viewer when using it in a script.\n                      From an interactive REPL such as IPython you should be able to\n                      just call ``Viewer.show()`` and the interactive viewer will appear\n                      while still allowing you to interact with the REPL.\n\n        \"\"\"\n        # This is for e.g. headless testing\n        if getattr(config, \"HEADLESS\", False):\n            logger.info(\"Viewer widget not shown - running in headless mode.\")\n            return\n\n        # Start the animation loop\n        self.canvas.request_draw(self._animate)\n\n        # If this is an offscreen canvas, we don't need to do anything else\n        if isinstance(self.canvas, OffscreenRenderCanvas):\n            return\n\n        # In terminal we can just show the window\n        if not self._is_jupyter:\n            # Not all backends have a show method (e.g. GLFW does not)\n            if hasattr(self.canvas, \"show\"):\n                self.canvas.show()\n\n            if start_loop:\n                from rendercanvas.auto import loop\n\n                loop.run()\n            elif utils._type_of_script() in (\"terminal\", \"script\"):\n                logger.warning(\n                    \"Running in a (potentially) non-interactive terminal or script \"\n                    \"environment. You may have to manually start the event loop \"\n                    \"for the canvas to render:\\n\\n\"\n                    \"  &gt;&gt;&gt; v = octarine.Viewer(show=False)\\n\"\n                    \"  &gt;&gt;&gt; ...  # setup your viewer\\n\"\n                    \"  &gt;&gt;&gt; v.show(start_loop=True)\\n\\n\"\n                    \"Alternatively, use the loop.run() function:\\n\\n\"\n                    \"  &gt;&gt;&gt; from rendercanvas.auto import loop\\n\"\n                    \"  &gt;&gt;&gt; ...  # setup your viewer\\n\"\n                    \"  &gt;&gt;&gt; v.show()\\n\"\n                    \"  &gt;&gt;&gt; loop.run()\\n\\n\"  # do not remove the \\n\\n here\n                )\n        else:\n            # if not hasattr(self, 'widget'):\n            from .jupyter import JupyterOutput\n            from IPython.display import display\n\n            # Construct the widget\n            if not hasattr(self, \"widget\"):\n                self.widget = JupyterOutput(\n                    self,\n                    use_sidecar=use_sidecar,\n                    toolbar=toolbar,\n                    sidecar_kwargs={\"title\": self._title},\n                )\n\n            # This will display the viewer right here and there\n            display(self.widget)\n\n    def show_message(\n        self, message, position=\"top-right\", font_size=20, color=None, duration=None\n    ):\n        \"\"\"Show message on canvas.\n\n        Parameters\n        ----------\n        message :   str | None\n                    Message to show. Set to `None` to remove the existing message.\n        position :  \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\" | \"center\"\n                    Position of the message on the canvas.\n        font_size : int, optional\n                    Font size of the message.\n        color :     str | tuple, optional\n                    Color of the message. If `None`, will use white.\n        duration :  int, optional\n                    Number of seconds after which to fade the message.\n\n        \"\"\"\n        if message is None and hasattr(self, \"_message_text\"):\n            if self._message_text.parent:\n                self.overlay_scene.remove(self._message_text)\n            del self._message_text\n            return\n\n        _positions = {\n            \"top-left\": (-0.95, 0.95, 0),\n            \"top-right\": (0.95, 0.95, 0),\n            \"bottom-left\": (-0.95, -0.95, 0),\n            \"bottom-right\": (0.95, -0.95, 0),\n            \"center\": (0, 0, 0),\n        }\n        if position not in _positions:\n            raise ValueError(f\"Unknown position: {position}\")\n\n        if not hasattr(self, \"_message_text\"):\n            self._message_text = text2gfx(\n                message, color=\"white\", font_size=font_size, screen_space=True\n            )\n\n        # Make sure the text is in the scene\n        if self._message_text not in self.overlay_scene.children:\n            self.overlay_scene.add(self._message_text)\n\n        self._message_text.set_text(message)\n        self._message_text.font_size = font_size\n        self._message_text.anchor = position\n        if color is not None:\n            self._message_text.material.color = cmap.Color(color).rgba\n        self._message_text.material.opacity = 1\n        self._message_text.local.position = _positions[position]\n\n        # When do we need to start fading out?\n        if duration:\n            self._fade_out_time = time.time() + duration\n\n            def _fade_message():\n                if not hasattr(self, \"_message_text\"):\n                    self.remove_animation(_fade_message)\n                else:\n                    if time.time() &gt; self._fade_out_time:\n                        # This means the text will fade fade over 1/0.02 = 50 frames\n                        self._message_text.material.opacity = max(\n                            self._message_text.material.opacity - 0.02, 0\n                        )\n\n                    if self._message_text.material.opacity &lt;= 0:\n                        if self._message_text.parent:\n                            self.overlay_scene.remove(self._message_text)\n                        self.remove_animation(_fade_message)\n\n            self.add_animation(_fade_message)\n\n    def show_controls(self):\n        \"\"\"Show controls.\"\"\"\n        if self._is_jupyter:\n            if self.widget.toolbar:\n                self.widget.toolbar.show()\n        else:\n            if not hasattr(self, \"_controls\"):\n                from .controls import Controls\n\n                self._controls = Controls(self)\n            self._controls.show()\n\n    def hide_controls(self):\n        \"\"\"Hide controls.\"\"\"\n        if self._is_jupyter:\n            if self.widget.toolbar:\n                self.widget.toolbar.hide()\n        else:\n            if hasattr(self, \"_controls\"):\n                self._controls.hide()\n\n    def _toggle_controls(self):\n        \"\"\"Switch controls on and off.\"\"\"\n        if self._is_jupyter:\n            if self.widget.toolbar:\n                self.widget.toolbar.toggle()\n        else:\n            if not hasattr(self, \"_controls\"):\n                self.show_controls()\n            elif self._controls.isVisible():\n                self.hide_controls()\n            else:\n                self.show_controls()\n\n    @update_viewer(legend=True, bounds=True)\n    def clear(self):\n        \"\"\"Clear canvas of objects (expects lights and background).\"\"\"\n        # Skip if running in headless mode\n        if getattr(config, \"HEADLESS\", False):\n            return\n\n        # Remove everything but the lights and backgrounds\n        self.scene.remove(*self.visuals)\n\n        # Rset the transform gizmo\n        self.transform_gizmo = None\n\n    @update_viewer(legend=True, bounds=True)\n    def remove_objects(self, to_remove):\n        \"\"\"Remove given neurons/visuals from canvas.\"\"\"\n        to_remove = utils.make_iterable(to_remove)\n\n        for vis in self.scene.children:\n            if vis in to_remove:\n                self.scene.remove(vis)\n            elif hasattr(vis, \"_object_id\"):\n                if vis._object_id in to_remove:\n                    self.scene.remove(vis)\n\n    @update_viewer(legend=True, bounds=True)\n    def pop(self, N=1):\n        \"\"\"Remove the most recently added N visuals.\"\"\"\n        for vis in list(self.objects.values())[-N:]:\n            self.remove_objects(vis)\n\n    @property\n    def show_bounds(self):\n        \"\"\"Set to ``True`` to show bounding box.\"\"\"\n        return self._show_bounds\n\n    @property\n    def show_fps(self):\n        \"\"\"Show frames per second.\"\"\"\n        return self._show_fps\n\n    @show_fps.setter\n    def show_fps(self, v):\n        if not isinstance(v, bool):\n            raise TypeError(f\"Expected bool, got {type(v)}\")\n        self._show_fps = v\n        self._render_stale = True\n\n    def toggle_bounds(self):\n        \"\"\"Toggle bounding box.\"\"\"\n        self.show_bounds = not self.show_bounds\n\n    @show_bounds.setter\n    def show_bounds(self, v):\n        if not isinstance(v, bool):\n            raise TypeError(f\"Need bool, got {type(v)}\")\n\n        self._show_bounds = v\n\n        if self.show_bounds:\n            self.update_bounds()\n        else:\n            self.remove_bounds()\n\n    def remove_bounds(self):\n        \"\"\"Remove bounding box visual.\"\"\"\n        self._show_bounds = False\n        for v in self.visuals:\n            if getattr(v, \"_object_type\", \"\") == \"boundingbox\":\n                self.remove_objects(v)\n\n    def resize(self, size):\n        \"\"\"Resize canvas.\n\n        Parameters\n        ----------\n        size :  (width, height) tuple\n                New size of the canvas.\n        \"\"\"\n        assert len(size) == 2\n        self.canvas.set_logical_size(*size)\n\n    def update_bounds(self, color=\"w\", width=1):\n        \"\"\"Update bounding box visual.\"\"\"\n        # Remove any existing visual\n        self.remove_bounds()\n\n        self._show_bounds = True\n\n        # Skip if no visual on canvas\n        bounds = self.scene.get_bounding_box()\n        if isinstance(bounds, type(None)):\n            return\n\n        # Create box visual\n        box = gfx.BoxHelper()\n        box.set_transform_by_aabb(bounds)\n\n        # Add custom attributes\n        box._object_type = \"boundingbox\"\n        box._object_id = uuid.uuid4()\n\n        self.scene.add(box)\n\n    def center_camera(self):\n        \"\"\"Center camera on visuals.\"\"\"\n        if len(self):\n            self.camera.show_object(\n                self.scene, scale=1, view_dir=(0.0, 0.0, 1.0), up=(0.0, -1.0, 0.0)\n            )\n\n    @update_viewer(legend=True, bounds=True)\n    def add(self, x, name=None, center=True, clear=False, **kwargs):\n        \"\"\"Add object to canvas.\n\n        This function is a general entry point for adding objects to the canvas.\n        It will look at the type of the input and try to find an appropriate\n        function to convert the input to visuals.\n\n        Use `octarine.register_converter` to add custom converters.\n\n        Parameters\n        ----------\n        x\n                    Object(s) to add to the canvas.\n        name :      str, optional\n                    Name for the visual(s).\n        center :    bool, optional\n                    If True, re-center camera to all objects on canvas.\n        clear :     bool, optional\n                    If True, clear canvas before adding new objects.\n        **kwargs\n                    Keyword arguments passed to the conversion functions when\n                    generating visuals.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        if clear:\n            self.clear()\n\n        if utils.is_iterable(x) and not isinstance(x, np.ndarray):\n            for xx in x:\n                self.add(xx, center=False, clear=False, name=name, **kwargs)\n            if center:\n                self.center_camera()\n            return\n\n        converter = get_converter(x, raise_missing=False)\n        if converter is None:\n            raise NotImplementedError(f\"No converter found for {x} ({type(x)})\")\n\n        # Check if we have to provide a color\n        if \"color\" not in kwargs and \"color\" in inspect.signature(converter).parameters:\n            kwargs[\"color\"] = tuple(self._next_color().rgba)\n\n        visuals = utils.make_iterable(converter(x, **kwargs))\n\n        for v in visuals:\n            # If we have a name, assign it to the visual\n            if name is not None:\n                v._object_id = name\n            # If not we either use existing ID or generate a new one\n            else:\n                # Give visuals an _object_id if they don't already have one\n                if not hasattr(v, \"_object_id\"):\n                    new_id = self._next_label(\"Object\")\n                    for v2 in visuals:\n                        v._object_id = new_id\n                elif not isinstance(v._object_id, str):\n                    v._object_id = str(v._object_id)\n\n            self.scene.add(v)\n\n        if center:\n            self.center_camera()\n\n    @update_viewer(legend=True, bounds=True)\n    def _add_to_scene(self, visual, center=True):\n        \"\"\"Add visual to scene.\n\n        This is just a convenient collection point for us to trigger a bunch of updates in one go,\n        \"\"\"\n        # If we need objects to be pickable, set the material accordingly\n        if self.objects_pickable:\n            try:\n                visual.material.pick_write = True\n            except AttributeError:\n                pass\n\n        self.scene.add(visual)\n\n        if center:\n            self.center_camera()\n\n    def add_mesh(self, mesh, name=None, color=None, alpha=None, center=True):\n        \"\"\"Add mesh to canvas.\n\n        Parameters\n        ----------\n        mesh :      Mesh-like\n                    Mesh to plot. If this is a pygfx.Mesh, it will be added\n                    directly to the scene without modification (i.e. `color`,\n                    `alpha`, etc. will be ignored).\n        name :      str, optional\n                    Name for the visual.\n        color :     str | tuple, optional\n                    Color to use for plotting. If multiple colors,\n                    must be a list of colors with the same length as\n                    the number of faces or vertices.\n        alpha :     float, optional\n                    Opacity value [0-1]. If provided, will override\n                    the alpha channel of the color.\n        center :    bool, optional\n                    If True, re-center camera to all objects on canvas.\n\n        \"\"\"\n        if isinstance(mesh, tm.Scene):\n            for _, ob in mesh.geometry.items():\n                self.add_mesh(ob, name=name, color=color, alpha=alpha, center=False)\n            return\n\n        if not utils.is_mesh_like(mesh):\n            raise TypeError(f\"Expected mesh-like object, got {type(mesh)}\")\n        if color is None:\n            color = self._next_color()\n        if name is None:\n            name = self._next_label(\"Mesh\")\n        elif not isinstance(name, str):\n            name = str(name)\n\n        if not isinstance(mesh, gfx.Mesh):\n            visual = mesh2gfx(mesh, color=color, alpha=alpha)\n        else:\n            visual = mesh\n\n        visual._object_id = name if name else uuid.uuid4()\n\n        self._add_to_scene(visual, center)\n\n    def add_points(\n        self,\n        points,\n        name=None,\n        color=None,\n        marker=None,\n        size=2,\n        size_space=\"screen\",\n        center=True,\n    ):\n        \"\"\"Add points plot to canvas.\n\n        Parameters\n        ----------\n        points :    (N, 3) array\n                    Points to plot.\n        name :      str, optional\n                    Name for the visual.\n        color :     str | tuple, optional\n                    Color to use for plotting. Can be the name of\n                    a colormap or a single color.\n        marker :    str, optional\n                    Marker to use for plotting. By default (None), will\n                    use a point. Other options include e.g. \"circle\", \"ring\"\n                    or \"diamond\". See `pygfx.MarkerShape` for the definitive\n                    list of options. Please note that you may have to\n                    increase the size of the marker to see some of the shapes.\n        size :      int | float\n                    Marker size. Can be a single value or an array of\n                    sizes for each point.\n        size_space : \"screen\" | \"world\" | \"model\", optional\n                    Units to use for the marker size. \"screen\" (default)\n                    will keep the line width constant on the screen, while\n                    \"world\" and \"model\" will keep it constant in world and\n                    model coordinates, respectively. In the latter two cases,\n                    `size` corresponds to the diameter (not radius) of the\n                    marker!\n        center :    bool, optional\n                    If True, re-center camera to all objects on canvas.\n\n        \"\"\"\n        if not isinstance(points, np.ndarray):\n            raise TypeError(f\"Expected numpy array, got {type(points)}\")\n        if points.ndim != 2 or points.shape[1] != 3:\n            raise ValueError(f\"Expected (N, 3) array, got {points.shape}\")\n        if color is None:\n            color = self._next_color()\n        if name is None:\n            name = self._next_label(\"Scatter\")\n        elif not isinstance(name, str):\n            name = str(name)\n\n        visual = points2gfx(\n            points, color=color, size=size, size_space=size_space, marker=marker\n        )\n        visual._object_id = name if name else uuid.uuid4()\n\n        self._add_to_scene(visual, center)\n\n    def add_lines(\n        self,\n        lines,\n        name=None,\n        color=None,\n        linewidth=1,\n        linewidth_space=\"screen\",\n        linestyle=\"solid\",\n        center=True,\n    ):\n        \"\"\"Add lines to canvas.\n\n        Parameters\n        ----------\n        lines :     list of (N, 3) arrays | (N, 3) array\n                    Lines to plot. If a list of arrays, each array\n                    represents a separate line. If a single array,\n                    each row represents a point in the line. You can\n                    introduce breaks in the line by inserting NaNs.\n        name :      str, optional\n                    Name for the visual.\n        color :     str | tuple, optional\n                    Color to use for plotting. Can be a single color\n                    or one for every point in the line(s).\n        linewidth : float, optional\n                    Line width.\n        linewidth_space : \"screen\" | \"world\" | \"model\", optional\n                    Units to use for the line width. \"screen\" (default)\n                    will keep the line width constant on the screen, while\n                    \"world\" and \"model\" will keep it constant in world and\n                    model coordinates, respectively.\n        linestyle : \"solid\" | \"dashed\" | \"dotted\" | \"dashdot\" | tuple, optional\n                    Line style to use. If a tuple, must define the on/off\n                    sequence.\n        center :    bool, optional\n                    If True, re-center camera to all objects on canvas.\n\n        \"\"\"\n        # TODO:\n        # - allow providing a tuple of (positions, edges) for lines\n\n        if isinstance(lines, np.ndarray):\n            if lines.ndim != 2 or lines.shape[1] != 3:\n                raise ValueError(f\"Expected (N, 3) array, got {lines.shape}\")\n        elif isinstance(lines, list):\n            if not all([l.ndim == 2 and l.shape[1] == 3 for l in lines]):\n                raise ValueError(\"Expected list of (N, 3) arrays.\")\n        else:\n            raise TypeError(f\"Expected numpy array or list, got {type(lines)}\")\n\n        if color is None:\n            color = self._next_color()\n        if name is None:\n            name = self._next_label(\"Lines\")\n        elif not isinstance(name, str):\n            name = str(name)\n\n        visual = lines2gfx(\n            lines,\n            linewidth=linewidth,\n            linewidth_space=linewidth_space,\n            color=color,\n            dash_pattern=linestyle,\n        )\n        visual._object_id = name if name else uuid.uuid4()\n        self._add_to_scene(visual, center)\n\n    def add_volume(\n        self,\n        volume,\n        spacing=(1, 1, 1),\n        name=None,\n        color=None,\n        opacity=1.0,\n        offset=(0, 0, 0),\n        clim=\"data\",\n        slice=False,\n        interpolation=\"linear\",\n        hide_zero=True,\n        center=True,\n    ):\n        \"\"\"Add image volume to canvas.\n\n        Note that the default blend mode for the renderer may cause objects\n        behind or inside the volume to look funny. You can change the blend\n        mode by setting e.g. `viewer.blend_mode='additive'`.\n\n        Parameters\n        ----------\n        volume :    (N, M, K) array\n                    Volume to plot.\n        spacing :   tuple\n                    Spacing between voxels.\n        name :      str, optional\n                    Name for the visual.\n        color :     color | list of colors | pygfx.Texture, optional\n                    Colormap to render the volume. This can be:\n                      - name of a colormap (e.g. \"viridis\" or \"magma\")\n                      - a single color (name, hex, rgb, rgba)\n                      - a list of colors\n                      - a 1D pygfx.Texture\n                    Note that single colors typically don't look good and\n                    it's better to define at least two colors. For example,\n                    instead of \"red\" use [\"red\", \"yellow\"]. If `None` will\n                    use one of the built-in pygfx colormaps.\n        opacity :   float, optional\n                    Overall opacity of the volume. Must be between 0 and 1.\n        offset :    tuple, optional\n                    (x, y, z) offset for the volume. If None, will use (0, 0, 0).\n        clim :      \"data\" | \"datatype\" | tuple, optional\n                    The contrast limits to scale the data values with.\n                      - \"data\" (default) will use the min/max of the data\n                      - \"datatype\" will use (0, theoretical max of data type)\n                        for integer data, e.g. (0, 255) for int8 and uint8,\n                        and (0, 1) for float data assuming the data has been\n                        normalized\n                      - tuple of min/max values or combination of \"data\" and\n                        \"datatype\" strings\n        slice :         bool | tuple, optional\n                        Render volume slices instead of the full volume:\n                        - True: render slices along all three dimensions\n                        - tuple of bools, e.g. `(True, True, False)`: render slices\n                          in the respective dimensions\n                        - tuple of floats, e.g. `(0.5, 0.5, 0.5)`: render slices\n                          at the respective positions (relative to the volume size)\n        interpolation : \"linear\" | \"nearest\"\n                    Interpolation to use when rendering the volume. \"linear\"\n                    (default) looks better but is slower.\n        hide_zero : bool\n                    If True, will hide voxels with lowest value according to `cmin`.\n        center :    bool, optional\n                    If True, re-center camera to all objects on canvas.\n\n        \"\"\"\n        if not isinstance(volume, np.ndarray):\n            raise TypeError(f\"Expected numpy array, got {type(volume)}\")\n        if volume.ndim != 3:\n            raise ValueError(f\"Expected 3D array, got {volume.ndim}\")\n        if name is None:\n            name = self._next_label(\"Volume\")\n        elif not isinstance(name, str):\n            name = str(name)\n\n        visuals = volume2gfx(\n            volume,\n            spacing=spacing,\n            offset=offset,\n            color=color,\n            opacity=opacity,\n            clim=clim,\n            slice=slice,\n            interpolation=interpolation,\n            hide_zero=hide_zero,\n        )\n        name = name if name else uuid.uuid4()\n        for vis in visuals:\n            vis._object_id = name if name else uuid.uuid4()\n            self._add_to_scene(vis, center)\n\n    def close(self):\n        \"\"\"Close the viewer.\"\"\"\n        # Skip if this is headless mode\n        if getattr(config, \"HEADLESS\", False):\n            return\n\n        # Clear first to free all visuals\n        self.clear()\n\n        # Remove from config if this is the primary viewer\n        if self == getattr(config, \"PRIMARY_VIEWER\", None):\n            del config.PRIMARY_VIEWER\n\n        # Close if not already closed\n        if not self.canvas.get_closed():\n            self.canvas.close()\n\n        if hasattr(self, \"_controls\"):\n            self._controls.close()\n\n        # Close the Jupyter widget\n        if hasattr(self, \"widget\") and not getattr(self.widget, \"_is_closed\", False):\n            self.widget.close(close_viewer=False)\n\n        try:\n            viewers.remove(self)\n        except ValueError:\n            pass\n\n    @update_viewer(legend=True, bounds=True)\n    def hide_objects(self, obj):\n        \"\"\"Hide given object(s).\n\n        Parameters\n        ----------\n        obj :   str | list\n                Object(s) to hide.\n\n        \"\"\"\n        objects = self.objects  # grab once to speed things up\n        for ob in utils.make_iterable(obj):\n            if ob not in objects:\n                logger.warning(f'Object \"{ob}\" not found on canvas.')\n                continue\n            for v in objects[ob]:\n                if getattr(v, \"_pinned\", False):\n                    continue\n                if v.visible:\n                    v.visible = False\n\n    @update_viewer(legend=True, bounds=True)\n    def hide_selected(self):\n        \"\"\"Hide currently selected object(s).\"\"\"\n        self.hide_neurons(self.selected)\n\n    @update_viewer(legend=True, bounds=True)\n    def unhide_objects(self, obj=None):\n        \"\"\"Unhide given object(s).\n\n        Parameters\n        ----------\n        obj :   str | list | None\n                Object(s) to unhide. If None, will unhide all objects.\n\n        \"\"\"\n        objects = self.objects  # grab once to speed things up\n        if obj is not None:\n            ids = utils.make_iterable(obj)\n        else:\n            ids = list(objects.keys())\n\n        for ob in ids:\n            if ob not in objects:\n                logger.warning(f\"Object {ob} not found on canvas.\")\n                continue\n            for v in objects[ob]:\n                if getattr(v, \"_pinned\", False):\n                    continue\n                if not v.visible:\n                    v.visible = True\n\n    def highlight_objects(self, obj, color=0.2):\n        \"\"\"Highlight given object(s) by increasing their brightness.\n\n        Parameters\n        ----------\n        obj :   str | int | list | visual\n                Object(s) to highlight. Can be the name(s) or ID(s) of\n                the object(s), their index(es) in the list of visuals,\n                or the visual(s) themselves. Objects already highlighted\n                will be silently ignored.\n        color : float | tuple\n                Color to use for highlighting. If a float, will change\n                the HSV value of the current color. If a tuple, will\n                use the RGB(A) color.\n\n        See Also\n        --------\n        Viewer.unhighlight_objects\n                Use to remove highlights.\n\n        \"\"\"\n        if not utils.is_iterable(obj):\n            objects = [obj]\n        else:\n            objects = obj\n\n        all_objects = self.objects  # grab once to speed things up\n\n        for ob in objects:\n            if ob in all_objects:\n                list_ = all_objects[ob]\n            elif isinstance(ob, int):\n                list_ = list(self.objects.values())[ob]\n            elif isinstance(ob, gfx.WorldObject):\n                list_ = [ob]\n            else:\n                raise TypeError(f\"Unknown object type: {type(ob)}\")\n\n            for o in list_:\n                # Skip if object is pinned\n                if getattr(o, \"_pinned\", False):\n                    continue\n                # Skip if object is already highlighted\n                if getattr(o, \"_highlighted\", False):\n                    continue\n\n                if isinstance(color, (float, int)):\n                    # Work in HSL space\n                    h, s, l = o.material.color.to_hsl()\n                    # If the value is not maxed yet, increase it\n                    if l &lt; 1:\n                        l = min(l + color, 1)\n                    else:\n                        l = max(l - color, 0)\n\n                    new_color = gfx.Color.from_hsl(h, s, l)\n                else:\n                    # See if pygfx can handle the color\n                    new_color = gfx.Color(color)\n\n                o.material._original_color = o.material.color\n                o.material.color = new_color\n                o._highlighted = True\n\n    def unhighlight_objects(self, obj=None):\n        \"\"\"Unhighlight given object(s).\n\n        Parameters\n        ----------\n        obj :   str | int | list | visual\n                Object(s) to unhighlight. Can be the name(s) or ID(s) of\n                the object(s), their index(es) in the list of visuals,\n                or the visual(s) themselves. If None, will unhighlight all\n                objects. Objects that aren't highlighted will be silently\n                ignored.\n\n        See Also\n        --------\n        Viewer.highlight_objects\n                Use to highlight objects\n\n        \"\"\"\n        # Important note: it looks like any attribute we added previously\n        # will (at some point) have been silently renamed to \"_Viewer{attribute}\"\n        if obj is None:\n            obj = [v for v in self.visuals if getattr(v, \"_highlighted\", False)]\n\n        if not utils.is_iterable(obj):\n            objects = [obj]\n        else:\n            objects = obj\n\n        all_objects = self.objects  # grab once to speed things up\n\n        for ob in objects:\n            if ob in all_objects:\n                list_ = all_objects[ob]\n            elif isinstance(ob, int):\n                list_ = list(self.visuals.values())[ob]\n            elif isinstance(ob, gfx.WorldObject):\n                list_ = [ob]\n            else:\n                raise TypeError(f\"Unknown object type: {type(ob)}\")\n\n            for o in list_:\n                # Skip if object is pinned\n                if getattr(o, \"_pinned\", False):\n                    continue\n\n                # Skip if object isn't actually highlighed\n                if not getattr(o, \"_highlighted\", False):\n                    continue\n                o.material.color = o.material._original_color\n                del o.material._original_color\n                del o._highlighted\n\n    def pin_objects(self, obj):\n        \"\"\"Pin given object(s).\n\n        Changes to the color or visibility of pinned neurons are silently\n        ignored. You can use this to keep specific neurons visible while\n        cycling through the rest - useful for comparisons.\n\n        \"\"\"\n        obj = utils.make_iterable(obj)\n        objects = self.objects  # grab only once to speed things up\n\n        for ob in obj:\n            if ob not in objects:\n                logger.warning(f\"Object {ob} not found on canvas.\")\n                continue\n            for v in objects[ob]:\n                v._pinned = True\n\n    def unpin_objects(self, obj=None):\n        \"\"\"Unpin given object(s).\n\n        Use ``obj`` to unhide specific neurons.\n\n        \"\"\"\n        objects = self.objects  # grab once to speed things up\n        if obj is None:\n            obj = objects\n        else:\n            obj = utils.make_iterable(obj)\n\n        for ob in obj:\n            if ob not in objects:\n                logger.warning(f\"Object {ob} not found on canvas.\")\n                continue\n            for v in objects[ob]:\n                v._pinned = False\n\n    @update_viewer(legend=False, bounds=False)\n    def set_alpha_mode(self, mode, objects=None):\n        \"\"\"Defines how objects' colors are blended.\n\n        With version v0.13.0 pygfx replaced the single renderer.blend_mode property with\n        customizable per-material alpha modes. The Viewer.set_alpha_mode function provides\n        a high-level interface to these settings. If you need more fine-grained control,\n        see the material.alpha_mode property of individual objects.\n\n        Parameters\n        ----------\n        mode :      str\n                    The mode to set. Please see the pygfx documentation for details:\n                      &gt;&gt;&gt; import pygfx\n                      &gt;&gt;&gt; help(pygfx.Material.alpha_mode)\n        objects :   list, optional\n                    Objects to set the alpha mode for. If None, will set for all objects.\n\n        \"\"\"\n        if objects is None:\n            objects = list(self.objects)\n\n        for n in objects:\n            for v in self.objects[n]:\n                if getattr(v, \"_pinned\", False):\n                    continue\n                if not hasattr(v, \"material\"):\n                    continue\n                v.material.alpha_mode = mode\n\n    @update_viewer(legend=True, bounds=False)\n    def set_colors(self, c, alpha_mode=\"auto\"):\n        \"\"\"Set object color.\n\n        Parameters\n        ----------\n        c :     tuple | dict\n                RGB color(s) to apply. Values must be 0-1. Accepted:\n                   1. Tuple of single color. Applied to all visible objects.\n                   2. Dictionary names/IDs to colors.\n        alpha_mode : str\n                If \"auto\" (default), will set the alpha mode to \"add\" if the\n                opacity is &lt; 1, and \"opaque\" otherwise. Set `alpha_mode` to `None` to\n                skip this adjustment.\n\n        \"\"\"\n        objects = self.objects  # grab once to speed things up\n        if isinstance(c, (tuple, list, np.ndarray, str)):\n            cmap = {s: c for s in objects}\n        elif isinstance(c, dict):\n            cmap = c\n        else:\n            raise TypeError(f'Unable to use colors of type \"{type(c)}\"')\n\n        for n in objects:\n            if n in cmap:\n                for v in objects[n]:\n                    if getattr(v, \"_pinned\", False):\n                        continue\n                    if not hasattr(v, \"material\"):\n                        continue\n                    # Note: there is currently a bug where removing or adding an alpha\n                    # channel from a color will break the rendering pipeline\n                    if len(v.material.color) == 4:\n                        new_c = gfx.Color(cmap[n]).rgba\n                    else:\n                        new_c = gfx.Color(cmap[n]).rgb\n                    v.material.color = gfx.Color(new_c)\n\n                    # Determine if we consider this transparent\n                    if len(new_c) == 4 and new_c[3] &lt; 1:\n                        is_transparent = True\n                    elif v.material.opacity &lt; 1:\n                        is_transparent = True\n                    else:\n                        is_transparent = False\n\n                    if alpha_mode == \"auto\":\n                        if is_transparent:\n                            v.material.alpha_mode = \"add\"\n                        else:\n                            v.material.alpha_mode = \"solid\"\n                    elif alpha_mode:\n                        v.material.alpha_mode = alpha_mode\n\n    def colorize(self, palette=\"seaborn:tab10\", objects=None, randomize=True):\n        \"\"\"Colorize objects using a color palette.\n\n        Parameters\n        ----------\n        palette :   str | cmap Colormap\n                    Name of the `cmap` palette to use. See\n                    https://cmap-docs.readthedocs.io/en/latest/catalog/#colormaps-by-category\n                    for available options.\n        objects :   list, optional\n                    Objects to colorize. If None, will colorize all objects.\n        randomize : bool\n                    If True (default), will randomly shuffle the colors.\n\n        \"\"\"\n        if objects is None:\n            objects = self.objects  # grab once to speed things up\n\n        if not isinstance(palette, cmap._colormap.Colormap):\n            palette = cmap.Colormap(palette)\n\n        if randomize:\n            # Note: can't use numpy here because it claims array is not 1d\n            colors = random.choices(list(palette.iter_colors()), k=len(objects))\n        else:\n            colors = list(palette.iter_colors(len(objects)))\n\n        colormap = {s: tuple(colors[i].rgba) for i, s in enumerate(objects)}\n\n        self.set_colors(colormap)\n\n    def set_bgcolor(self, c):\n        \"\"\"Set background color.\n\n        Parameters\n        ----------\n        c :     tuple | str\n                RGB(A) color to use for the background.\n\n        \"\"\"\n        self._background.material.set_colors(gfx.Color(c).rgba)\n\n    def _toggle_fps(self):\n        \"\"\"Switch FPS measurement on and off.\"\"\"\n        self.show_fps = not self.show_fps\n\n    def screenshot(\n        self, filename=\"screenshot.png\", size=None, pixel_ratio=None, alpha=True\n    ):\n        \"\"\"Save a screenshot of the canvas.\n\n        Parameters\n        ----------\n        filename :      str | pathlib.Path, optional\n                        Filename to save to. If ``None``, will return image array.\n                        Note that this will always save a PNG file, no matter\n                        the extension.\n        size :          tuple, optional\n                        Size of the screenshot. If provided, will temporarily\n                        change the canvas size.\n        pixel_ratio :   int, optional\n                        Factor by which to scale canvas. Determines image\n                        dimensions. Note that this seems to have no effect\n                        on offscreen canvases.\n        alpha :         bool, optional\n                        If True, will export transparent background.\n\n        \"\"\"\n        im = self._screenshot(alpha=alpha, size=size, pixel_ratio=pixel_ratio)\n        if filename:\n            filename = Path(filename)\n            if filename.suffix != \".png\":\n                filename = filename.parent / f\"{filename.name}.png\"\n            png.from_array(\n                im.reshape(im.shape[0], im.shape[1] * im.shape[2]), mode=\"RGBA\"\n            ).save(str(filename.resolve()))\n        else:\n            return im\n\n    def _screenshot(self, alpha=True, size=None, pixel_ratio=None):\n        \"\"\"Return image array for screenshot.\"\"\"\n        if alpha:\n            vis = self._background.visible\n            self._background.visible = False\n        if size:\n            os = self.size\n            self.size = size\n        if pixel_ratio:\n            opr = self.renderer.pixel_ratio\n            self.renderer.pixel_ratio = pixel_ratio\n\n        # If this is an offscreen canvas, we need to manually trigger a draw first\n        # Note: this has to happen _after_ adjust parameters!\n        if isinstance(self.canvas, OffscreenRenderCanvas):\n            self.canvas.draw()\n        else:\n            # This is a bit of a hack to make sure a new frame with the (potentially)\n            # updated size, pixel ratio, etc. is drawn before taking the screenshot.\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\")\n                self.canvas._subwidget._draw_frame_and_present()\n\n        try:\n            im = self.renderer.snapshot()\n        except BaseException:\n            raise\n        finally:\n            if alpha:\n                self._background.visible = vis\n            if size:\n                self.size = os\n            if pixel_ratio:\n                self.renderer.pixel_ratio = opr\n\n        return im\n\n    def set_view(self, view):\n        \"\"\"(Re-)set camera position.\n\n        Parameters\n        ----------\n        view :      XY | XZ | YZ | dict\n                    View to set. Can be inverted to e.g. \"-XY\" to show view from back.\n                    If a dictionary, should describe the state of the camera. Typically,\n                    this is obtained by calling `viewer.get_view()`.\n\n        \"\"\"\n        if view == \"XY\":\n            self.camera.show_object(\n                self.scene, view_dir=(0.0, 0.0, 1.0), up=(0.0, -1.0, 0.0)\n            )\n        elif view == \"-XY\":\n            self.camera.show_object(\n                self.scene, view_dir=(0.0, 0.0, -1.0), up=(0.0, -1.0, 0.0)\n            )\n        elif view == \"XZ\":\n            self.camera.show_object(\n                self.scene, scale=1, view_dir=(0.0, 1.0, 0.0), up=(0.0, 0.0, 1.0)\n            )\n        elif view == \"-XZ\":\n            self.camera.show_object(\n                self.scene, scale=1, view_dir=(0.0, -1.0, 0.0), up=(0.0, 0.0, 1.0)\n            )\n        elif view == \"YZ\":\n            self.camera.show_object(\n                self.scene, scale=1, view_dir=(1.0, 0.0, 0.0), up=(0.0, -1.0, 0.0)\n            )\n        elif view == \"YZ\":\n            self.camera.show_object(\n                self.scene, scale=1, view_dir=(-1.0, 0.0, 0.0), up=(0.0, -1.0, 0.0)\n            )\n        elif isinstance(view, dict):\n            self.camera.set_state(view)\n        else:\n            raise TypeError(f\"Unable to set view from {type(view)}\")\n\n    def get_view(self):\n        \"\"\"Get current camera position.\"\"\"\n        return self.camera.get_state()\n\n    def bind_key(self, key, func, modifiers=None):\n        \"\"\"Bind a function to a key press.\n\n        Note that any existing keybindings for `key` + `modifiers` will be\n        silently overwritten.\n\n        Parameters\n        ----------\n        key :       str\n                    Key to bind to. Can be any key on the keyboard.\n        func :      callable\n                    Function to call when key is pressed.\n        modifiers : str | list thereof, optional\n                    Modifier(s) to use with the key. Can be \"Shift\", \"Control\",\n                    \"Alt\" or \"Meta\".\n\n        \"\"\"\n        if not callable(func):\n            raise TypeError(\"`func` needs to be callable\")\n\n        if not isinstance(key, str):\n            raise TypeError(f\"Expected `key` to be a string, got {type(key)}\")\n\n        if modifiers is None:\n            self._key_events[key] = func\n        else:\n            # We need to make `modifiers` is hashable\n            if isinstance(modifiers, str):\n                modifiers = (modifiers,)\n            elif isinstance(modifiers, (set, list)):\n                modifiers = tuple(modifiers)\n\n            if not isinstance(modifiers, tuple):\n                raise TypeError(\n                    f\"Unexpected datatype for `modifiers`: {type(modifiers)}\"\n                )\n\n            self._key_events[(key, modifiers)] = func\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.blend_mode","title":"<code>blend_mode</code>  <code>property</code>","text":"<p>Deprecated! Render blend mode.</p> <p>This property has been deprecated. Please use <code>Viewer.set_alpha_mode()</code> instead.</p>"},{"location":"api/viewer/#octarine.Viewer.bounds","title":"<code>bounds</code>  <code>property</code>","text":"<p>Bounds of all currently visuals (visible and invisible).</p>"},{"location":"api/viewer/#octarine.Viewer.controls","title":"<code>controls</code>  <code>property</code>","text":"<p>Return the controls widget.</p>"},{"location":"api/viewer/#octarine.Viewer.highlighted","title":"<code>highlighted</code>  <code>property</code>","text":"<p>Return IDs of currently highlighted objects.</p>"},{"location":"api/viewer/#octarine.Viewer.invisible","title":"<code>invisible</code>  <code>property</code>","text":"<p>List IDs of currently visible objects.</p>"},{"location":"api/viewer/#octarine.Viewer.max_fps","title":"<code>max_fps</code>  <code>property</code> <code>writable</code>","text":"<p>Maximum frames per second to render.</p>"},{"location":"api/viewer/#octarine.Viewer.moveable_object","title":"<code>moveable_object</code>  <code>property</code> <code>writable</code>","text":"<p>Get/Set the object that can be moved via the transform gizmo.</p>"},{"location":"api/viewer/#octarine.Viewer.on_double_click","title":"<code>on_double_click</code>  <code>property</code> <code>writable</code>","text":"<p>Determines what to do when double clicking on objects.</p> <p>Can be set to:  - <code>None</code>: do nothing  - \"hide\": hide object  - \"remove\": remove object  - \"select\": select object</p>"},{"location":"api/viewer/#octarine.Viewer.on_hover","title":"<code>on_hover</code>  <code>property</code> <code>writable</code>","text":"<p>Determines what to do when hovering over objects.</p> <p>Can be set to:  - <code>None</code>: do nothing  - \"highlight\": hide object</p>"},{"location":"api/viewer/#octarine.Viewer.pinned","title":"<code>pinned</code>  <code>property</code>","text":"<p>List IDs of currently pinned objects.</p>"},{"location":"api/viewer/#octarine.Viewer.render_trigger","title":"<code>render_trigger</code>  <code>property</code> <code>writable</code>","text":"<p>Determines when the scene is (re)rendered.</p> <p>By default, we leave it to the renderer to decide when to render the scene. You can adjust that behaviour by setting render mode to:  - \"continuous\" (default): leave it to the renderer to decide when to render the scene  - \"reactive\": rendering is only triggered when the scene changes  - \"active_window\": rendering is only done when the window is active; this currently    only works with the PySide backend</p>"},{"location":"api/viewer/#octarine.Viewer.selected","title":"<code>selected</code>  <code>property</code> <code>writable</code>","text":"<p>Return IDs of or set selected objects.</p>"},{"location":"api/viewer/#octarine.Viewer.shadows","title":"<code>shadows</code>  <code>property</code> <code>writable</code>","text":"<p>Return shadow state.</p>"},{"location":"api/viewer/#octarine.Viewer.show_bounds","title":"<code>show_bounds</code>  <code>property</code> <code>writable</code>","text":"<p>Set to <code>True</code> to show bounding box.</p>"},{"location":"api/viewer/#octarine.Viewer.show_fps","title":"<code>show_fps</code>  <code>property</code> <code>writable</code>","text":"<p>Show frames per second.</p>"},{"location":"api/viewer/#octarine.Viewer.size","title":"<code>size</code>  <code>property</code> <code>writable</code>","text":"<p>Return size of the canvas.</p>"},{"location":"api/viewer/#octarine.Viewer.visible","title":"<code>visible</code>  <code>property</code>","text":"<p>List IDs of currently visible objects.</p>"},{"location":"api/viewer/#octarine.Viewer.visuals","title":"<code>visuals</code>  <code>property</code>","text":"<p>List of all visuals on this canvas.</p>"},{"location":"api/viewer/#octarine.Viewer.__init__","title":"<code>__init__(offscreen=False, title='Octarine Viewer', max_fps=30, camera='ortho', control='trackball', size=None, show=True, **kwargs)</code>","text":"Source code in <code>octarine/viewer.py</code> <pre><code>def __init__(\n    self,\n    offscreen=False,\n    title=\"Octarine Viewer\",\n    max_fps=30,\n    camera=\"ortho\",\n    control=\"trackball\",\n    size=None,\n    show=True,\n    **kwargs,\n):\n    # We need to import WgpuCanvas before we (potentially) start the event loop\n    # If we don't we get a segfault.\n    if not offscreen:\n        from rendercanvas.auto import RenderCanvas\n\n    # Check if we're running in an IPython environment\n    if utils._type_of_script() == \"ipython\" and not offscreen:\n        ip = get_ipython()  # noqa: F821\n        if not ip.active_eventloop:\n            if AUTOSTART_EVENT_LOOP:\n                try:\n                    ip.enable_gui(\"qt6\")\n                    logger.debug(\n                        \"Looks like you're running in an IPython environment but haven't \"\n                        \"started a GUI event loop. We've started one for you using the \"\n                        \"Qt6 backend.\"\n                    )\n                except (ModuleNotFoundError, ImportError):\n                    raise ValueError(\n                        \"Looks like you're running in an IPython environment but haven't \"\n                        \"started a GUI event loop. We tried to start one for you using the \"\n                        \"Qt6 backend (via %gui qt6) but that failed. You may have to start \"\n                        \"the event loop manually. See \"\n                        \"https://ipython.readthedocs.io/en/stable/config/eventloops.html\"\n                        \"for details.\"\n                    )\n            else:\n                raise ValueError(\n                    'IPython event loop not running. Please use e.g. \"%gui qt6\" to hook into the event loop.'\n                )\n\n    self._title = title\n\n    # Update some defaults as necessary\n    defaults = {\"title\": title, \"max_fps\": max_fps}\n    if size is not None:\n        defaults[\"size\"] = size\n    defaults.update(kwargs)\n\n    # If we're running in headless mode (primarily for tests on CI) we will\n    # simply not initialize the gfx objects. Not ideal but it turns\n    # out to be very annoying to correctly setup on Github Actions.\n    if getattr(config, \"HEADLESS\", False):\n        return\n\n    if not offscreen:\n        self.canvas = RenderCanvas(**defaults)\n    else:\n        self.canvas = OffscreenRenderCanvas(**defaults)\n\n    # There is a bug in pygfx 0.1.18 that causes the renderer to crash\n    # when using a Jupyter canvas without explicitly setting the pixel_ratio.\n    # This is already fixed in main but for now:\n    if self._is_jupyter:\n        self.renderer = gfx.renderers.WgpuRenderer(\n            self.canvas, show_fps=False, pixel_ratio=2\n        )\n    else:\n        self.renderer = gfx.renderers.WgpuRenderer(self.canvas, show_fps=False)\n\n    # Set up a default scene\n    self.scene = gfx.Scene()\n\n    # A minor ambient light\n    self.scene.add(gfx.AmbientLight(intensity=0.5))\n\n    # A strong point light form front/top/left\n    self.scene.add(gfx.PointLight(intensity=4))\n    self.scene.children[-1].shadow.bias = 0.0000005  # this helps with shadow acne\n    self.scene.children[-1].local.x = -1000000  # move to the left\n    self.scene.children[-1].local.y = -1000000  # move up\n    self.scene.children[-1].local.z = -1000000  # move light forward\n\n    # A weaker point light from the back\n    self.scene.add(gfx.PointLight(intensity=1))\n    self.scene.children[-1].shadow.bias = 0.0000005  # this helps with shadow acne\n    self.scene.children[-1].local.x = 1000000  # move to the left\n    self.scene.children[-1].local.y = 1000000  # move up\n    self.scene.children[-1].local.z = 1000000  # move light forward\n\n    # Set up a default background\n    self._background = gfx.Background(None, gfx.BackgroundMaterial((0, 0, 0)))\n    self.scene.add(self._background)\n\n    # Add camera\n    if camera == \"ortho\":\n        self.camera = gfx.OrthographicCamera()\n    elif camera == \"perspective\":\n        self.camera = gfx.PerspectiveCamera()\n    else:\n        raise ValueError(f\"Unknown camera type: {camera}\")\n\n    # Add controller\n    controller = {\n        \"trackball\": gfx.TrackballController,\n        \"panzoom\": gfx.PanZoomController,\n        \"fly\": gfx.FlyController,\n        \"orbit\": gfx.OrbitController,\n    }.get(control, None)\n    if controller is None:\n        raise ValueError(f\"Unknown controller type: {control}\")\n\n    self.controller = controller(self.camera, register_events=self.renderer)\n\n    # Setup overlay\n    self.overlay_camera = gfx.NDCCamera()\n    self.overlay_scene = gfx.Scene()\n\n    # Setup transform gizmo\n    self.transform_gizmo = None\n\n    # Stats\n    self.stats = gfx.Stats(self.renderer)\n    self._show_fps = False\n\n    # Setup key events\n    self._key_events = {}\n    self._key_events[\"1\"] = lambda: self.set_view(\"XY\")  # frontal view\n    self._key_events[\"2\"] = lambda: self.set_view(\"XZ\")  # lateral view\n    self._key_events[\"3\"] = lambda: self.set_view(\"YZ\")  # top view\n    self._key_events[(\"1\", (\"Shift\",))] = lambda: self.set_view(\"-XY\")  # back view\n    self._key_events[(\"2\", (\"Shift\",))] = lambda: self.set_view(\n        \"-XZ\"\n    )  # other lateral view\n    self._key_events[(\"3\", (\"Shift\",))] = lambda: self.set_view(\n        \"-YZ\"\n    )  # bottom view\n    self._key_events[\"f\"] = lambda: self._toggle_fps()\n    self._key_events[\"c\"] = lambda: self._toggle_controls()\n\n    def _keydown(event):\n        \"\"\"Handle key presses.\"\"\"\n        if not event.modifiers:\n            if event.key in self._key_events:\n                self._key_events[event.key]()\n        else:\n            tup = (event.key, tuple(event.modifiers))\n            if tup in self._key_events:\n                self._key_events[tup]()\n\n    # Register events\n    self.renderer.add_event_handler(_keydown, \"key_down\")\n\n    # Finally, setting some variables\n    self._show_bounds = False\n    self._shadows = False\n    self._animations = {}\n    self._animations_flagged_for_removal = []\n    self._animations_frame_counter = 0\n    self._on_double_click = None\n    self._on_hover = None\n    self._objects_pickable = False\n    self._selected = []\n    self._render_trigger = \"continuous\"\n\n    viewers.append(self)\n\n    # This starts the animation loop\n    if show and not self._is_jupyter:\n        self.show(start_loop=show == \"start_loop\")\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.add","title":"<code>add(x, name=None, center=True, clear=False, **kwargs)</code>","text":"<p>Add object to canvas.</p> <p>This function is a general entry point for adding objects to the canvas. It will look at the type of the input and try to find an appropriate function to convert the input to visuals.</p> <p>Use <code>octarine.register_converter</code> to add custom converters.</p> PARAMETER DESCRIPTION <code>x</code> <pre><code>    Object(s) to add to the canvas.\n</code></pre> <p> </p> <code>name</code> <pre><code>    Name for the visual(s).\n</code></pre> <p> TYPE: <code>     str</code> DEFAULT: <code>None</code> </p> <code>center</code> <pre><code>    If True, re-center camera to all objects on canvas.\n</code></pre> <p> TYPE: <code>   bool</code> DEFAULT: <code>True</code> </p> <code>clear</code> <pre><code>    If True, clear canvas before adding new objects.\n</code></pre> <p> TYPE: <code>    bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <pre><code>    Keyword arguments passed to the conversion functions when\n    generating visuals.\n</code></pre> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> Source code in <code>octarine/viewer.py</code> <pre><code>@update_viewer(legend=True, bounds=True)\ndef add(self, x, name=None, center=True, clear=False, **kwargs):\n    \"\"\"Add object to canvas.\n\n    This function is a general entry point for adding objects to the canvas.\n    It will look at the type of the input and try to find an appropriate\n    function to convert the input to visuals.\n\n    Use `octarine.register_converter` to add custom converters.\n\n    Parameters\n    ----------\n    x\n                Object(s) to add to the canvas.\n    name :      str, optional\n                Name for the visual(s).\n    center :    bool, optional\n                If True, re-center camera to all objects on canvas.\n    clear :     bool, optional\n                If True, clear canvas before adding new objects.\n    **kwargs\n                Keyword arguments passed to the conversion functions when\n                generating visuals.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    if clear:\n        self.clear()\n\n    if utils.is_iterable(x) and not isinstance(x, np.ndarray):\n        for xx in x:\n            self.add(xx, center=False, clear=False, name=name, **kwargs)\n        if center:\n            self.center_camera()\n        return\n\n    converter = get_converter(x, raise_missing=False)\n    if converter is None:\n        raise NotImplementedError(f\"No converter found for {x} ({type(x)})\")\n\n    # Check if we have to provide a color\n    if \"color\" not in kwargs and \"color\" in inspect.signature(converter).parameters:\n        kwargs[\"color\"] = tuple(self._next_color().rgba)\n\n    visuals = utils.make_iterable(converter(x, **kwargs))\n\n    for v in visuals:\n        # If we have a name, assign it to the visual\n        if name is not None:\n            v._object_id = name\n        # If not we either use existing ID or generate a new one\n        else:\n            # Give visuals an _object_id if they don't already have one\n            if not hasattr(v, \"_object_id\"):\n                new_id = self._next_label(\"Object\")\n                for v2 in visuals:\n                    v._object_id = new_id\n            elif not isinstance(v._object_id, str):\n                v._object_id = str(v._object_id)\n\n        self.scene.add(v)\n\n    if center:\n        self.center_camera()\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.add_animation","title":"<code>add_animation(x, on_error='remove', run_every=None, req_render=True)</code>","text":"<p>Add animation function to the Viewer.</p> PARAMETER DESCRIPTION <code>x</code> <pre><code>    Function to add to the animation loop.\n</code></pre> <p> TYPE: <code>        callable</code> </p> <code>on_error</code> <pre><code>    What to do if the function throws an error. If \"remove\",\n    the function will be removed from the animation loop. If\n    \"ignore\", the error will be ignored and the function will\n    continue to be called.\n</code></pre> <p> TYPE: <code> \"remove\" | \"ignore\" | \"raise\"</code> DEFAULT: <code>'remove'</code> </p> <code>run_every</code> <pre><code>    Use to run the function every n frames.\n</code></pre> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>req_render</code> <pre><code>    Whether this animation requires a re-render of the scene.\n    This is mainly a flag to help the viewer to decide\n    whether/when to trigger a render. See also the `render_trigger`\n    property.\n</code></pre> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def add_animation(self, x, on_error=\"remove\", run_every=None, req_render=True):\n    \"\"\"Add animation function to the Viewer.\n\n    Parameters\n    ----------\n    x :         callable\n                Function to add to the animation loop.\n    on_error :  \"remove\" | \"ignore\" | \"raise\"\n                What to do if the function throws an error. If \"remove\",\n                the function will be removed from the animation loop. If\n                \"ignore\", the error will be ignored and the function will\n                continue to be called.\n    run_every : int, optional\n                Use to run the function every n frames.\n    req_render : bool, optional\n                Whether this animation requires a re-render of the scene.\n                This is mainly a flag to help the viewer to decide\n                whether/when to trigger a render. See also the `render_trigger`\n                property.\n\n    \"\"\"\n    if not callable(x):\n        raise TypeError(f\"Expected callable, got {type(x)}\")\n\n    assert on_error in [\"remove\", \"ignore\", \"raise\"]\n\n    self._animations[x] = (on_error, run_every, req_render)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.add_effect","title":"<code>add_effect(effect, **kwargs)</code>","text":"<p>Add post-processing effect to the renderer.</p> <p>You can also use this method to adjust the parameters of an existing effect.</p> PARAMETER DESCRIPTION <code>effect</code> <pre><code>    Name of the effect to add. Currently supported:\n     - \"edl\" (Eye-Dome Lighting)\n       This effect enhances depth perception for complex\n       geometries by darkening edges based on depth differences.\n</code></pre> <p> TYPE: <code>  str</code> </p> <code>**kwargs</code> <pre><code>    Keyword arguments passed to the effect constructor:\n    - edl:\n      - strength (default 5): EDL strength; ypical range ~ [0.5, 10.0].\n      - radius (default 1.5): sampling radius in pixels\n      - depth_edge_threshold (default 0.0)\n</code></pre> <p> DEFAULT: <code>{}</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def add_effect(self, effect, **kwargs):\n    \"\"\"Add post-processing effect to the renderer.\n\n    You can also use this method to adjust the parameters of an existing effect.\n\n    Parameters\n    ----------\n    effect :   str\n                Name of the effect to add. Currently supported:\n                 - \"edl\" (Eye-Dome Lighting)\n                   This effect enhances depth perception for complex\n                   geometries by darkening edges based on depth differences.\n\n    **kwargs\n                Keyword arguments passed to the effect constructor:\n                - edl:\n                  - strength (default 5): EDL strength; ypical range ~ [0.5, 10.0].\n                  - radius (default 1.5): sampling radius in pixels\n                  - depth_edge_threshold (default 0.0)\n\n    \"\"\"\n    effect = EFFECT_CLASSES.get(effect, None)\n    if effect is None:\n        raise ValueError(f\"Unknown effect: {effect}\")\n\n    # Check if we already have this effect\n    p = None\n    for e in self.renderer.effect_passes:\n        if isinstance(e, effect):\n            p = e\n            break\n\n    if p is None:\n        # Overwrite the default of 1 (seems too weak in my hands)\n        if (effect is EDLPass) and \"strength\" not in kwargs:\n            kwargs[\"strength\"] = 5.0\n\n        p = effect(**kwargs)\n        self.renderer.effect_passes = tuple(list(self.renderer.effect_passes) + [p])\n    else:\n        # Update parameters\n        for k, v in kwargs.items():\n            if hasattr(p, k):\n                setattr(p, k, v)\n            else:\n                raise ValueError(f\"Effect '{effect}' has no parameter '{k}'\")\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.add_lines","title":"<code>add_lines(lines, name=None, color=None, linewidth=1, linewidth_space='screen', linestyle='solid', center=True)</code>","text":"<p>Add lines to canvas.</p> PARAMETER DESCRIPTION <code>lines</code> <pre><code>    Lines to plot. If a list of arrays, each array\n    represents a separate line. If a single array,\n    each row represents a point in the line. You can\n    introduce breaks in the line by inserting NaNs.\n</code></pre> <p> TYPE: <code>    list of (N, 3) arrays | (N, 3) array</code> </p> <code>name</code> <pre><code>    Name for the visual.\n</code></pre> <p> TYPE: <code>     str</code> DEFAULT: <code>None</code> </p> <code>color</code> <pre><code>    Color to use for plotting. Can be a single color\n    or one for every point in the line(s).\n</code></pre> <p> TYPE: <code>    str | tuple</code> DEFAULT: <code>None</code> </p> <code>linewidth</code> <pre><code>    Line width.\n</code></pre> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> <code>linewidth_space</code> <pre><code>    Units to use for the line width. \"screen\" (default)\n    will keep the line width constant on the screen, while\n    \"world\" and \"model\" will keep it constant in world and\n    model coordinates, respectively.\n</code></pre> <p> TYPE: <code>screen | world | model</code> DEFAULT: <code>'screen'</code> </p> <code>linestyle</code> <pre><code>    Line style to use. If a tuple, must define the on/off\n    sequence.\n</code></pre> <p> TYPE: <code>solid | dashed | dotted | dashdot | tuple</code> DEFAULT: <code>'solid'</code> </p> <code>center</code> <pre><code>    If True, re-center camera to all objects on canvas.\n</code></pre> <p> TYPE: <code>   bool</code> DEFAULT: <code>True</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def add_lines(\n    self,\n    lines,\n    name=None,\n    color=None,\n    linewidth=1,\n    linewidth_space=\"screen\",\n    linestyle=\"solid\",\n    center=True,\n):\n    \"\"\"Add lines to canvas.\n\n    Parameters\n    ----------\n    lines :     list of (N, 3) arrays | (N, 3) array\n                Lines to plot. If a list of arrays, each array\n                represents a separate line. If a single array,\n                each row represents a point in the line. You can\n                introduce breaks in the line by inserting NaNs.\n    name :      str, optional\n                Name for the visual.\n    color :     str | tuple, optional\n                Color to use for plotting. Can be a single color\n                or one for every point in the line(s).\n    linewidth : float, optional\n                Line width.\n    linewidth_space : \"screen\" | \"world\" | \"model\", optional\n                Units to use for the line width. \"screen\" (default)\n                will keep the line width constant on the screen, while\n                \"world\" and \"model\" will keep it constant in world and\n                model coordinates, respectively.\n    linestyle : \"solid\" | \"dashed\" | \"dotted\" | \"dashdot\" | tuple, optional\n                Line style to use. If a tuple, must define the on/off\n                sequence.\n    center :    bool, optional\n                If True, re-center camera to all objects on canvas.\n\n    \"\"\"\n    # TODO:\n    # - allow providing a tuple of (positions, edges) for lines\n\n    if isinstance(lines, np.ndarray):\n        if lines.ndim != 2 or lines.shape[1] != 3:\n            raise ValueError(f\"Expected (N, 3) array, got {lines.shape}\")\n    elif isinstance(lines, list):\n        if not all([l.ndim == 2 and l.shape[1] == 3 for l in lines]):\n            raise ValueError(\"Expected list of (N, 3) arrays.\")\n    else:\n        raise TypeError(f\"Expected numpy array or list, got {type(lines)}\")\n\n    if color is None:\n        color = self._next_color()\n    if name is None:\n        name = self._next_label(\"Lines\")\n    elif not isinstance(name, str):\n        name = str(name)\n\n    visual = lines2gfx(\n        lines,\n        linewidth=linewidth,\n        linewidth_space=linewidth_space,\n        color=color,\n        dash_pattern=linestyle,\n    )\n    visual._object_id = name if name else uuid.uuid4()\n    self._add_to_scene(visual, center)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.add_mesh","title":"<code>add_mesh(mesh, name=None, color=None, alpha=None, center=True)</code>","text":"<p>Add mesh to canvas.</p> PARAMETER DESCRIPTION <code>mesh</code> <pre><code>    Mesh to plot. If this is a pygfx.Mesh, it will be added\n    directly to the scene without modification (i.e. `color`,\n    `alpha`, etc. will be ignored).\n</code></pre> <p> TYPE: <code>     Mesh-like</code> </p> <code>name</code> <pre><code>    Name for the visual.\n</code></pre> <p> TYPE: <code>     str</code> DEFAULT: <code>None</code> </p> <code>color</code> <pre><code>    Color to use for plotting. If multiple colors,\n    must be a list of colors with the same length as\n    the number of faces or vertices.\n</code></pre> <p> TYPE: <code>    str | tuple</code> DEFAULT: <code>None</code> </p> <code>alpha</code> <pre><code>    Opacity value [0-1]. If provided, will override\n    the alpha channel of the color.\n</code></pre> <p> TYPE: <code>    float</code> DEFAULT: <code>None</code> </p> <code>center</code> <pre><code>    If True, re-center camera to all objects on canvas.\n</code></pre> <p> TYPE: <code>   bool</code> DEFAULT: <code>True</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def add_mesh(self, mesh, name=None, color=None, alpha=None, center=True):\n    \"\"\"Add mesh to canvas.\n\n    Parameters\n    ----------\n    mesh :      Mesh-like\n                Mesh to plot. If this is a pygfx.Mesh, it will be added\n                directly to the scene without modification (i.e. `color`,\n                `alpha`, etc. will be ignored).\n    name :      str, optional\n                Name for the visual.\n    color :     str | tuple, optional\n                Color to use for plotting. If multiple colors,\n                must be a list of colors with the same length as\n                the number of faces or vertices.\n    alpha :     float, optional\n                Opacity value [0-1]. If provided, will override\n                the alpha channel of the color.\n    center :    bool, optional\n                If True, re-center camera to all objects on canvas.\n\n    \"\"\"\n    if isinstance(mesh, tm.Scene):\n        for _, ob in mesh.geometry.items():\n            self.add_mesh(ob, name=name, color=color, alpha=alpha, center=False)\n        return\n\n    if not utils.is_mesh_like(mesh):\n        raise TypeError(f\"Expected mesh-like object, got {type(mesh)}\")\n    if color is None:\n        color = self._next_color()\n    if name is None:\n        name = self._next_label(\"Mesh\")\n    elif not isinstance(name, str):\n        name = str(name)\n\n    if not isinstance(mesh, gfx.Mesh):\n        visual = mesh2gfx(mesh, color=color, alpha=alpha)\n    else:\n        visual = mesh\n\n    visual._object_id = name if name else uuid.uuid4()\n\n    self._add_to_scene(visual, center)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.add_points","title":"<code>add_points(points, name=None, color=None, marker=None, size=2, size_space='screen', center=True)</code>","text":"<p>Add points plot to canvas.</p> PARAMETER DESCRIPTION <code>points</code> <pre><code>    Points to plot.\n</code></pre> <p> TYPE: <code>   (N, 3) array</code> </p> <code>name</code> <pre><code>    Name for the visual.\n</code></pre> <p> TYPE: <code>     str</code> DEFAULT: <code>None</code> </p> <code>color</code> <pre><code>    Color to use for plotting. Can be the name of\n    a colormap or a single color.\n</code></pre> <p> TYPE: <code>    str | tuple</code> DEFAULT: <code>None</code> </p> <code>marker</code> <pre><code>    Marker to use for plotting. By default (None), will\n    use a point. Other options include e.g. \"circle\", \"ring\"\n    or \"diamond\". See `pygfx.MarkerShape` for the definitive\n    list of options. Please note that you may have to\n    increase the size of the marker to see some of the shapes.\n</code></pre> <p> TYPE: <code>   str</code> DEFAULT: <code>None</code> </p> <code>size</code> <pre><code>    Marker size. Can be a single value or an array of\n    sizes for each point.\n</code></pre> <p> TYPE: <code>     int | float</code> DEFAULT: <code>2</code> </p> <code>size_space</code> <pre><code>    Units to use for the marker size. \"screen\" (default)\n    will keep the line width constant on the screen, while\n    \"world\" and \"model\" will keep it constant in world and\n    model coordinates, respectively. In the latter two cases,\n    `size` corresponds to the diameter (not radius) of the\n    marker!\n</code></pre> <p> TYPE: <code>screen | world | model</code> DEFAULT: <code>'screen'</code> </p> <code>center</code> <pre><code>    If True, re-center camera to all objects on canvas.\n</code></pre> <p> TYPE: <code>   bool</code> DEFAULT: <code>True</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def add_points(\n    self,\n    points,\n    name=None,\n    color=None,\n    marker=None,\n    size=2,\n    size_space=\"screen\",\n    center=True,\n):\n    \"\"\"Add points plot to canvas.\n\n    Parameters\n    ----------\n    points :    (N, 3) array\n                Points to plot.\n    name :      str, optional\n                Name for the visual.\n    color :     str | tuple, optional\n                Color to use for plotting. Can be the name of\n                a colormap or a single color.\n    marker :    str, optional\n                Marker to use for plotting. By default (None), will\n                use a point. Other options include e.g. \"circle\", \"ring\"\n                or \"diamond\". See `pygfx.MarkerShape` for the definitive\n                list of options. Please note that you may have to\n                increase the size of the marker to see some of the shapes.\n    size :      int | float\n                Marker size. Can be a single value or an array of\n                sizes for each point.\n    size_space : \"screen\" | \"world\" | \"model\", optional\n                Units to use for the marker size. \"screen\" (default)\n                will keep the line width constant on the screen, while\n                \"world\" and \"model\" will keep it constant in world and\n                model coordinates, respectively. In the latter two cases,\n                `size` corresponds to the diameter (not radius) of the\n                marker!\n    center :    bool, optional\n                If True, re-center camera to all objects on canvas.\n\n    \"\"\"\n    if not isinstance(points, np.ndarray):\n        raise TypeError(f\"Expected numpy array, got {type(points)}\")\n    if points.ndim != 2 or points.shape[1] != 3:\n        raise ValueError(f\"Expected (N, 3) array, got {points.shape}\")\n    if color is None:\n        color = self._next_color()\n    if name is None:\n        name = self._next_label(\"Scatter\")\n    elif not isinstance(name, str):\n        name = str(name)\n\n    visual = points2gfx(\n        points, color=color, size=size, size_space=size_space, marker=marker\n    )\n    visual._object_id = name if name else uuid.uuid4()\n\n    self._add_to_scene(visual, center)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.add_volume","title":"<code>add_volume(volume, spacing=(1, 1, 1), name=None, color=None, opacity=1.0, offset=(0, 0, 0), clim='data', slice=False, interpolation='linear', hide_zero=True, center=True)</code>","text":"<p>Add image volume to canvas.</p> <p>Note that the default blend mode for the renderer may cause objects behind or inside the volume to look funny. You can change the blend mode by setting e.g. <code>viewer.blend_mode='additive'</code>.</p> PARAMETER DESCRIPTION <code>volume</code> <pre><code>    Volume to plot.\n</code></pre> <p> TYPE: <code>   (N, M, K) array</code> </p> <code>spacing</code> <pre><code>    Spacing between voxels.\n</code></pre> <p> TYPE: <code>  tuple</code> DEFAULT: <code>(1, 1, 1)</code> </p> <code>name</code> <pre><code>    Name for the visual.\n</code></pre> <p> TYPE: <code>     str</code> DEFAULT: <code>None</code> </p> <code>color</code> <pre><code>    Colormap to render the volume. This can be:\n      - name of a colormap (e.g. \"viridis\" or \"magma\")\n      - a single color (name, hex, rgb, rgba)\n      - a list of colors\n      - a 1D pygfx.Texture\n    Note that single colors typically don't look good and\n    it's better to define at least two colors. For example,\n    instead of \"red\" use [\"red\", \"yellow\"]. If `None` will\n    use one of the built-in pygfx colormaps.\n</code></pre> <p> TYPE: <code>    color | list of colors | pygfx.Texture</code> DEFAULT: <code>None</code> </p> <code>opacity</code> <pre><code>    Overall opacity of the volume. Must be between 0 and 1.\n</code></pre> <p> TYPE: <code>  float</code> DEFAULT: <code>1.0</code> </p> <code>offset</code> <pre><code>    (x, y, z) offset for the volume. If None, will use (0, 0, 0).\n</code></pre> <p> TYPE: <code>   tuple</code> DEFAULT: <code>(0, 0, 0)</code> </p> <code>clim</code> <pre><code>    The contrast limits to scale the data values with.\n      - \"data\" (default) will use the min/max of the data\n      - \"datatype\" will use (0, theoretical max of data type)\n        for integer data, e.g. (0, 255) for int8 and uint8,\n        and (0, 1) for float data assuming the data has been\n        normalized\n      - tuple of min/max values or combination of \"data\" and\n        \"datatype\" strings\n</code></pre> <p> TYPE: <code>     \"data\" | \"datatype\" | tuple</code> DEFAULT: <code>'data'</code> </p> <code>slice</code> <pre><code>        Render volume slices instead of the full volume:\n        - True: render slices along all three dimensions\n        - tuple of bools, e.g. `(True, True, False)`: render slices\n          in the respective dimensions\n        - tuple of floats, e.g. `(0.5, 0.5, 0.5)`: render slices\n          at the respective positions (relative to the volume size)\n</code></pre> <p> TYPE: <code>        bool | tuple</code> DEFAULT: <code>False</code> </p> <code>interpolation</code> <pre><code>    Interpolation to use when rendering the volume. \"linear\"\n    (default) looks better but is slower.\n</code></pre> <p> TYPE: <code>linear | nearest</code> DEFAULT: <code>'linear'</code> </p> <code>hide_zero</code> <pre><code>    If True, will hide voxels with lowest value according to `cmin`.\n</code></pre> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>center</code> <pre><code>    If True, re-center camera to all objects on canvas.\n</code></pre> <p> TYPE: <code>   bool</code> DEFAULT: <code>True</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def add_volume(\n    self,\n    volume,\n    spacing=(1, 1, 1),\n    name=None,\n    color=None,\n    opacity=1.0,\n    offset=(0, 0, 0),\n    clim=\"data\",\n    slice=False,\n    interpolation=\"linear\",\n    hide_zero=True,\n    center=True,\n):\n    \"\"\"Add image volume to canvas.\n\n    Note that the default blend mode for the renderer may cause objects\n    behind or inside the volume to look funny. You can change the blend\n    mode by setting e.g. `viewer.blend_mode='additive'`.\n\n    Parameters\n    ----------\n    volume :    (N, M, K) array\n                Volume to plot.\n    spacing :   tuple\n                Spacing between voxels.\n    name :      str, optional\n                Name for the visual.\n    color :     color | list of colors | pygfx.Texture, optional\n                Colormap to render the volume. This can be:\n                  - name of a colormap (e.g. \"viridis\" or \"magma\")\n                  - a single color (name, hex, rgb, rgba)\n                  - a list of colors\n                  - a 1D pygfx.Texture\n                Note that single colors typically don't look good and\n                it's better to define at least two colors. For example,\n                instead of \"red\" use [\"red\", \"yellow\"]. If `None` will\n                use one of the built-in pygfx colormaps.\n    opacity :   float, optional\n                Overall opacity of the volume. Must be between 0 and 1.\n    offset :    tuple, optional\n                (x, y, z) offset for the volume. If None, will use (0, 0, 0).\n    clim :      \"data\" | \"datatype\" | tuple, optional\n                The contrast limits to scale the data values with.\n                  - \"data\" (default) will use the min/max of the data\n                  - \"datatype\" will use (0, theoretical max of data type)\n                    for integer data, e.g. (0, 255) for int8 and uint8,\n                    and (0, 1) for float data assuming the data has been\n                    normalized\n                  - tuple of min/max values or combination of \"data\" and\n                    \"datatype\" strings\n    slice :         bool | tuple, optional\n                    Render volume slices instead of the full volume:\n                    - True: render slices along all three dimensions\n                    - tuple of bools, e.g. `(True, True, False)`: render slices\n                      in the respective dimensions\n                    - tuple of floats, e.g. `(0.5, 0.5, 0.5)`: render slices\n                      at the respective positions (relative to the volume size)\n    interpolation : \"linear\" | \"nearest\"\n                Interpolation to use when rendering the volume. \"linear\"\n                (default) looks better but is slower.\n    hide_zero : bool\n                If True, will hide voxels with lowest value according to `cmin`.\n    center :    bool, optional\n                If True, re-center camera to all objects on canvas.\n\n    \"\"\"\n    if not isinstance(volume, np.ndarray):\n        raise TypeError(f\"Expected numpy array, got {type(volume)}\")\n    if volume.ndim != 3:\n        raise ValueError(f\"Expected 3D array, got {volume.ndim}\")\n    if name is None:\n        name = self._next_label(\"Volume\")\n    elif not isinstance(name, str):\n        name = str(name)\n\n    visuals = volume2gfx(\n        volume,\n        spacing=spacing,\n        offset=offset,\n        color=color,\n        opacity=opacity,\n        clim=clim,\n        slice=slice,\n        interpolation=interpolation,\n        hide_zero=hide_zero,\n    )\n    name = name if name else uuid.uuid4()\n    for vis in visuals:\n        vis._object_id = name if name else uuid.uuid4()\n        self._add_to_scene(vis, center)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.bind_key","title":"<code>bind_key(key, func, modifiers=None)</code>","text":"<p>Bind a function to a key press.</p> <p>Note that any existing keybindings for <code>key</code> + <code>modifiers</code> will be silently overwritten.</p> PARAMETER DESCRIPTION <code>key</code> <pre><code>    Key to bind to. Can be any key on the keyboard.\n</code></pre> <p> TYPE: <code>      str</code> </p> <code>func</code> <pre><code>    Function to call when key is pressed.\n</code></pre> <p> TYPE: <code>     callable</code> </p> <code>modifiers</code> <pre><code>    Modifier(s) to use with the key. Can be \"Shift\", \"Control\",\n    \"Alt\" or \"Meta\".\n</code></pre> <p> TYPE: <code>str | list thereof</code> DEFAULT: <code>None</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def bind_key(self, key, func, modifiers=None):\n    \"\"\"Bind a function to a key press.\n\n    Note that any existing keybindings for `key` + `modifiers` will be\n    silently overwritten.\n\n    Parameters\n    ----------\n    key :       str\n                Key to bind to. Can be any key on the keyboard.\n    func :      callable\n                Function to call when key is pressed.\n    modifiers : str | list thereof, optional\n                Modifier(s) to use with the key. Can be \"Shift\", \"Control\",\n                \"Alt\" or \"Meta\".\n\n    \"\"\"\n    if not callable(func):\n        raise TypeError(\"`func` needs to be callable\")\n\n    if not isinstance(key, str):\n        raise TypeError(f\"Expected `key` to be a string, got {type(key)}\")\n\n    if modifiers is None:\n        self._key_events[key] = func\n    else:\n        # We need to make `modifiers` is hashable\n        if isinstance(modifiers, str):\n            modifiers = (modifiers,)\n        elif isinstance(modifiers, (set, list)):\n            modifiers = tuple(modifiers)\n\n        if not isinstance(modifiers, tuple):\n            raise TypeError(\n                f\"Unexpected datatype for `modifiers`: {type(modifiers)}\"\n            )\n\n        self._key_events[(key, modifiers)] = func\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.center_camera","title":"<code>center_camera()</code>","text":"<p>Center camera on visuals.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def center_camera(self):\n    \"\"\"Center camera on visuals.\"\"\"\n    if len(self):\n        self.camera.show_object(\n            self.scene, scale=1, view_dir=(0.0, 0.0, 1.0), up=(0.0, -1.0, 0.0)\n        )\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.clear","title":"<code>clear()</code>","text":"<p>Clear canvas of objects (expects lights and background).</p> Source code in <code>octarine/viewer.py</code> <pre><code>@update_viewer(legend=True, bounds=True)\ndef clear(self):\n    \"\"\"Clear canvas of objects (expects lights and background).\"\"\"\n    # Skip if running in headless mode\n    if getattr(config, \"HEADLESS\", False):\n        return\n\n    # Remove everything but the lights and backgrounds\n    self.scene.remove(*self.visuals)\n\n    # Rset the transform gizmo\n    self.transform_gizmo = None\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.close","title":"<code>close()</code>","text":"<p>Close the viewer.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def close(self):\n    \"\"\"Close the viewer.\"\"\"\n    # Skip if this is headless mode\n    if getattr(config, \"HEADLESS\", False):\n        return\n\n    # Clear first to free all visuals\n    self.clear()\n\n    # Remove from config if this is the primary viewer\n    if self == getattr(config, \"PRIMARY_VIEWER\", None):\n        del config.PRIMARY_VIEWER\n\n    # Close if not already closed\n    if not self.canvas.get_closed():\n        self.canvas.close()\n\n    if hasattr(self, \"_controls\"):\n        self._controls.close()\n\n    # Close the Jupyter widget\n    if hasattr(self, \"widget\") and not getattr(self.widget, \"_is_closed\", False):\n        self.widget.close(close_viewer=False)\n\n    try:\n        viewers.remove(self)\n    except ValueError:\n        pass\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.colorize","title":"<code>colorize(palette='seaborn:tab10', objects=None, randomize=True)</code>","text":"<p>Colorize objects using a color palette.</p> PARAMETER DESCRIPTION <code>palette</code> <pre><code>    Name of the `cmap` palette to use. See\n    https://cmap-docs.readthedocs.io/en/latest/catalog/#colormaps-by-category\n    for available options.\n</code></pre> <p> TYPE: <code>  str | cmap Colormap</code> DEFAULT: <code>'seaborn:tab10'</code> </p> <code>objects</code> <pre><code>    Objects to colorize. If None, will colorize all objects.\n</code></pre> <p> TYPE: <code>  list</code> DEFAULT: <code>None</code> </p> <code>randomize</code> <pre><code>    If True (default), will randomly shuffle the colors.\n</code></pre> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def colorize(self, palette=\"seaborn:tab10\", objects=None, randomize=True):\n    \"\"\"Colorize objects using a color palette.\n\n    Parameters\n    ----------\n    palette :   str | cmap Colormap\n                Name of the `cmap` palette to use. See\n                https://cmap-docs.readthedocs.io/en/latest/catalog/#colormaps-by-category\n                for available options.\n    objects :   list, optional\n                Objects to colorize. If None, will colorize all objects.\n    randomize : bool\n                If True (default), will randomly shuffle the colors.\n\n    \"\"\"\n    if objects is None:\n        objects = self.objects  # grab once to speed things up\n\n    if not isinstance(palette, cmap._colormap.Colormap):\n        palette = cmap.Colormap(palette)\n\n    if randomize:\n        # Note: can't use numpy here because it claims array is not 1d\n        colors = random.choices(list(palette.iter_colors()), k=len(objects))\n    else:\n        colors = list(palette.iter_colors(len(objects)))\n\n    colormap = {s: tuple(colors[i].rgba) for i, s in enumerate(objects)}\n\n    self.set_colors(colormap)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.get_view","title":"<code>get_view()</code>","text":"<p>Get current camera position.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def get_view(self):\n    \"\"\"Get current camera position.\"\"\"\n    return self.camera.get_state()\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.hide_controls","title":"<code>hide_controls()</code>","text":"<p>Hide controls.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def hide_controls(self):\n    \"\"\"Hide controls.\"\"\"\n    if self._is_jupyter:\n        if self.widget.toolbar:\n            self.widget.toolbar.hide()\n    else:\n        if hasattr(self, \"_controls\"):\n            self._controls.hide()\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.hide_objects","title":"<code>hide_objects(obj)</code>","text":"<p>Hide given object(s).</p> PARAMETER DESCRIPTION <code>obj</code> <pre><code>Object(s) to hide.\n</code></pre> <p> TYPE: <code>  str | list</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>@update_viewer(legend=True, bounds=True)\ndef hide_objects(self, obj):\n    \"\"\"Hide given object(s).\n\n    Parameters\n    ----------\n    obj :   str | list\n            Object(s) to hide.\n\n    \"\"\"\n    objects = self.objects  # grab once to speed things up\n    for ob in utils.make_iterable(obj):\n        if ob not in objects:\n            logger.warning(f'Object \"{ob}\" not found on canvas.')\n            continue\n        for v in objects[ob]:\n            if getattr(v, \"_pinned\", False):\n                continue\n            if v.visible:\n                v.visible = False\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.hide_selected","title":"<code>hide_selected()</code>","text":"<p>Hide currently selected object(s).</p> Source code in <code>octarine/viewer.py</code> <pre><code>@update_viewer(legend=True, bounds=True)\ndef hide_selected(self):\n    \"\"\"Hide currently selected object(s).\"\"\"\n    self.hide_neurons(self.selected)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.highlight_objects","title":"<code>highlight_objects(obj, color=0.2)</code>","text":"<p>Highlight given object(s) by increasing their brightness.</p> PARAMETER DESCRIPTION <code>obj</code> <pre><code>Object(s) to highlight. Can be the name(s) or ID(s) of\nthe object(s), their index(es) in the list of visuals,\nor the visual(s) themselves. Objects already highlighted\nwill be silently ignored.\n</code></pre> <p> TYPE: <code>  str | int | list | visual</code> </p> <code>color</code> <pre><code>Color to use for highlighting. If a float, will change\nthe HSV value of the current color. If a tuple, will\nuse the RGB(A) color.\n</code></pre> <p> TYPE: <code>float | tuple</code> DEFAULT: <code>0.2</code> </p> See Also <p>Viewer.unhighlight_objects         Use to remove highlights.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def highlight_objects(self, obj, color=0.2):\n    \"\"\"Highlight given object(s) by increasing their brightness.\n\n    Parameters\n    ----------\n    obj :   str | int | list | visual\n            Object(s) to highlight. Can be the name(s) or ID(s) of\n            the object(s), their index(es) in the list of visuals,\n            or the visual(s) themselves. Objects already highlighted\n            will be silently ignored.\n    color : float | tuple\n            Color to use for highlighting. If a float, will change\n            the HSV value of the current color. If a tuple, will\n            use the RGB(A) color.\n\n    See Also\n    --------\n    Viewer.unhighlight_objects\n            Use to remove highlights.\n\n    \"\"\"\n    if not utils.is_iterable(obj):\n        objects = [obj]\n    else:\n        objects = obj\n\n    all_objects = self.objects  # grab once to speed things up\n\n    for ob in objects:\n        if ob in all_objects:\n            list_ = all_objects[ob]\n        elif isinstance(ob, int):\n            list_ = list(self.objects.values())[ob]\n        elif isinstance(ob, gfx.WorldObject):\n            list_ = [ob]\n        else:\n            raise TypeError(f\"Unknown object type: {type(ob)}\")\n\n        for o in list_:\n            # Skip if object is pinned\n            if getattr(o, \"_pinned\", False):\n                continue\n            # Skip if object is already highlighted\n            if getattr(o, \"_highlighted\", False):\n                continue\n\n            if isinstance(color, (float, int)):\n                # Work in HSL space\n                h, s, l = o.material.color.to_hsl()\n                # If the value is not maxed yet, increase it\n                if l &lt; 1:\n                    l = min(l + color, 1)\n                else:\n                    l = max(l - color, 0)\n\n                new_color = gfx.Color.from_hsl(h, s, l)\n            else:\n                # See if pygfx can handle the color\n                new_color = gfx.Color(color)\n\n            o.material._original_color = o.material.color\n            o.material.color = new_color\n            o._highlighted = True\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.pin_objects","title":"<code>pin_objects(obj)</code>","text":"<p>Pin given object(s).</p> <p>Changes to the color or visibility of pinned neurons are silently ignored. You can use this to keep specific neurons visible while cycling through the rest - useful for comparisons.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def pin_objects(self, obj):\n    \"\"\"Pin given object(s).\n\n    Changes to the color or visibility of pinned neurons are silently\n    ignored. You can use this to keep specific neurons visible while\n    cycling through the rest - useful for comparisons.\n\n    \"\"\"\n    obj = utils.make_iterable(obj)\n    objects = self.objects  # grab only once to speed things up\n\n    for ob in obj:\n        if ob not in objects:\n            logger.warning(f\"Object {ob} not found on canvas.\")\n            continue\n        for v in objects[ob]:\n            v._pinned = True\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.pop","title":"<code>pop(N=1)</code>","text":"<p>Remove the most recently added N visuals.</p> Source code in <code>octarine/viewer.py</code> <pre><code>@update_viewer(legend=True, bounds=True)\ndef pop(self, N=1):\n    \"\"\"Remove the most recently added N visuals.\"\"\"\n    for vis in list(self.objects.values())[-N:]:\n        self.remove_objects(vis)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.remove_animation","title":"<code>remove_animation(x)</code>","text":"<p>Remove animation function from the Viewer.</p> PARAMETER DESCRIPTION <code>x</code> <pre><code>Either the function itself or its index\nin the list of animations.\n</code></pre> <p> TYPE: <code>    callable | int</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def remove_animation(self, x):\n    \"\"\"Remove animation function from the Viewer.\n\n    Parameters\n    ----------\n    x :     callable | int\n            Either the function itself or its index\n            in the list of animations.\n\n    \"\"\"\n    if callable(x):\n        self._animations_flagged_for_removal.append(x)\n    elif isinstance(x, int):\n        self._animations_flagged_for_removal.append(\n            list(self._animations.keys())[x]\n        )\n    else:\n        raise TypeError(f\"Expected callable or index (int), got {type(x)}\")\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.remove_bounds","title":"<code>remove_bounds()</code>","text":"<p>Remove bounding box visual.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def remove_bounds(self):\n    \"\"\"Remove bounding box visual.\"\"\"\n    self._show_bounds = False\n    for v in self.visuals:\n        if getattr(v, \"_object_type\", \"\") == \"boundingbox\":\n            self.remove_objects(v)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.remove_objects","title":"<code>remove_objects(to_remove)</code>","text":"<p>Remove given neurons/visuals from canvas.</p> Source code in <code>octarine/viewer.py</code> <pre><code>@update_viewer(legend=True, bounds=True)\ndef remove_objects(self, to_remove):\n    \"\"\"Remove given neurons/visuals from canvas.\"\"\"\n    to_remove = utils.make_iterable(to_remove)\n\n    for vis in self.scene.children:\n        if vis in to_remove:\n            self.scene.remove(vis)\n        elif hasattr(vis, \"_object_id\"):\n            if vis._object_id in to_remove:\n                self.scene.remove(vis)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.resize","title":"<code>resize(size)</code>","text":"<p>Resize canvas.</p> PARAMETER DESCRIPTION <code>size</code> <pre><code>New size of the canvas.\n</code></pre> <p> TYPE: <code> (width, height) tuple</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def resize(self, size):\n    \"\"\"Resize canvas.\n\n    Parameters\n    ----------\n    size :  (width, height) tuple\n            New size of the canvas.\n    \"\"\"\n    assert len(size) == 2\n    self.canvas.set_logical_size(*size)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.screenshot","title":"<code>screenshot(filename='screenshot.png', size=None, pixel_ratio=None, alpha=True)</code>","text":"<p>Save a screenshot of the canvas.</p> PARAMETER DESCRIPTION <code>filename</code> <pre><code>        Filename to save to. If ``None``, will return image array.\n        Note that this will always save a PNG file, no matter\n        the extension.\n</code></pre> <p> TYPE: <code>     str | pathlib.Path</code> DEFAULT: <code>'screenshot.png'</code> </p> <code>size</code> <pre><code>        Size of the screenshot. If provided, will temporarily\n        change the canvas size.\n</code></pre> <p> TYPE: <code>         tuple</code> DEFAULT: <code>None</code> </p> <code>pixel_ratio</code> <pre><code>        Factor by which to scale canvas. Determines image\n        dimensions. Note that this seems to have no effect\n        on offscreen canvases.\n</code></pre> <p> TYPE: <code>  int</code> DEFAULT: <code>None</code> </p> <code>alpha</code> <pre><code>        If True, will export transparent background.\n</code></pre> <p> TYPE: <code>        bool</code> DEFAULT: <code>True</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def screenshot(\n    self, filename=\"screenshot.png\", size=None, pixel_ratio=None, alpha=True\n):\n    \"\"\"Save a screenshot of the canvas.\n\n    Parameters\n    ----------\n    filename :      str | pathlib.Path, optional\n                    Filename to save to. If ``None``, will return image array.\n                    Note that this will always save a PNG file, no matter\n                    the extension.\n    size :          tuple, optional\n                    Size of the screenshot. If provided, will temporarily\n                    change the canvas size.\n    pixel_ratio :   int, optional\n                    Factor by which to scale canvas. Determines image\n                    dimensions. Note that this seems to have no effect\n                    on offscreen canvases.\n    alpha :         bool, optional\n                    If True, will export transparent background.\n\n    \"\"\"\n    im = self._screenshot(alpha=alpha, size=size, pixel_ratio=pixel_ratio)\n    if filename:\n        filename = Path(filename)\n        if filename.suffix != \".png\":\n            filename = filename.parent / f\"{filename.name}.png\"\n        png.from_array(\n            im.reshape(im.shape[0], im.shape[1] * im.shape[2]), mode=\"RGBA\"\n        ).save(str(filename.resolve()))\n    else:\n        return im\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.set_alpha_mode","title":"<code>set_alpha_mode(mode, objects=None)</code>","text":"<p>Defines how objects' colors are blended.</p> <p>With version v0.13.0 pygfx replaced the single renderer.blend_mode property with customizable per-material alpha modes. The Viewer.set_alpha_mode function provides a high-level interface to these settings. If you need more fine-grained control, see the material.alpha_mode property of individual objects.</p> PARAMETER DESCRIPTION <code>mode</code> <pre><code>    The mode to set. Please see the pygfx documentation for details:\n      &gt;&gt;&gt; import pygfx\n      &gt;&gt;&gt; help(pygfx.Material.alpha_mode)\n</code></pre> <p> TYPE: <code>     str</code> </p> <code>objects</code> <pre><code>    Objects to set the alpha mode for. If None, will set for all objects.\n</code></pre> <p> TYPE: <code>  list</code> DEFAULT: <code>None</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>@update_viewer(legend=False, bounds=False)\ndef set_alpha_mode(self, mode, objects=None):\n    \"\"\"Defines how objects' colors are blended.\n\n    With version v0.13.0 pygfx replaced the single renderer.blend_mode property with\n    customizable per-material alpha modes. The Viewer.set_alpha_mode function provides\n    a high-level interface to these settings. If you need more fine-grained control,\n    see the material.alpha_mode property of individual objects.\n\n    Parameters\n    ----------\n    mode :      str\n                The mode to set. Please see the pygfx documentation for details:\n                  &gt;&gt;&gt; import pygfx\n                  &gt;&gt;&gt; help(pygfx.Material.alpha_mode)\n    objects :   list, optional\n                Objects to set the alpha mode for. If None, will set for all objects.\n\n    \"\"\"\n    if objects is None:\n        objects = list(self.objects)\n\n    for n in objects:\n        for v in self.objects[n]:\n            if getattr(v, \"_pinned\", False):\n                continue\n            if not hasattr(v, \"material\"):\n                continue\n            v.material.alpha_mode = mode\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.set_bgcolor","title":"<code>set_bgcolor(c)</code>","text":"<p>Set background color.</p> PARAMETER DESCRIPTION <code>c</code> <pre><code>RGB(A) color to use for the background.\n</code></pre> <p> TYPE: <code>    tuple | str</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def set_bgcolor(self, c):\n    \"\"\"Set background color.\n\n    Parameters\n    ----------\n    c :     tuple | str\n            RGB(A) color to use for the background.\n\n    \"\"\"\n    self._background.material.set_colors(gfx.Color(c).rgba)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.set_colors","title":"<code>set_colors(c, alpha_mode='auto')</code>","text":"<p>Set object color.</p> PARAMETER DESCRIPTION <code>c</code> <pre><code>RGB color(s) to apply. Values must be 0-1. Accepted:\n   1. Tuple of single color. Applied to all visible objects.\n   2. Dictionary names/IDs to colors.\n</code></pre> <p> TYPE: <code>    tuple | dict</code> </p> <code>alpha_mode</code> <pre><code>If \"auto\" (default), will set the alpha mode to \"add\" if the\nopacity is &lt; 1, and \"opaque\" otherwise. Set `alpha_mode` to `None` to\nskip this adjustment.\n</code></pre> <p> TYPE: <code>str</code> DEFAULT: <code>'auto'</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>@update_viewer(legend=True, bounds=False)\ndef set_colors(self, c, alpha_mode=\"auto\"):\n    \"\"\"Set object color.\n\n    Parameters\n    ----------\n    c :     tuple | dict\n            RGB color(s) to apply. Values must be 0-1. Accepted:\n               1. Tuple of single color. Applied to all visible objects.\n               2. Dictionary names/IDs to colors.\n    alpha_mode : str\n            If \"auto\" (default), will set the alpha mode to \"add\" if the\n            opacity is &lt; 1, and \"opaque\" otherwise. Set `alpha_mode` to `None` to\n            skip this adjustment.\n\n    \"\"\"\n    objects = self.objects  # grab once to speed things up\n    if isinstance(c, (tuple, list, np.ndarray, str)):\n        cmap = {s: c for s in objects}\n    elif isinstance(c, dict):\n        cmap = c\n    else:\n        raise TypeError(f'Unable to use colors of type \"{type(c)}\"')\n\n    for n in objects:\n        if n in cmap:\n            for v in objects[n]:\n                if getattr(v, \"_pinned\", False):\n                    continue\n                if not hasattr(v, \"material\"):\n                    continue\n                # Note: there is currently a bug where removing or adding an alpha\n                # channel from a color will break the rendering pipeline\n                if len(v.material.color) == 4:\n                    new_c = gfx.Color(cmap[n]).rgba\n                else:\n                    new_c = gfx.Color(cmap[n]).rgb\n                v.material.color = gfx.Color(new_c)\n\n                # Determine if we consider this transparent\n                if len(new_c) == 4 and new_c[3] &lt; 1:\n                    is_transparent = True\n                elif v.material.opacity &lt; 1:\n                    is_transparent = True\n                else:\n                    is_transparent = False\n\n                if alpha_mode == \"auto\":\n                    if is_transparent:\n                        v.material.alpha_mode = \"add\"\n                    else:\n                        v.material.alpha_mode = \"solid\"\n                elif alpha_mode:\n                    v.material.alpha_mode = alpha_mode\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.set_view","title":"<code>set_view(view)</code>","text":"<p>(Re-)set camera position.</p> PARAMETER DESCRIPTION <code>view</code> <pre><code>    View to set. Can be inverted to e.g. \"-XY\" to show view from back.\n    If a dictionary, should describe the state of the camera. Typically,\n    this is obtained by calling `viewer.get_view()`.\n</code></pre> <p> TYPE: <code>     XY | XZ | YZ | dict</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def set_view(self, view):\n    \"\"\"(Re-)set camera position.\n\n    Parameters\n    ----------\n    view :      XY | XZ | YZ | dict\n                View to set. Can be inverted to e.g. \"-XY\" to show view from back.\n                If a dictionary, should describe the state of the camera. Typically,\n                this is obtained by calling `viewer.get_view()`.\n\n    \"\"\"\n    if view == \"XY\":\n        self.camera.show_object(\n            self.scene, view_dir=(0.0, 0.0, 1.0), up=(0.0, -1.0, 0.0)\n        )\n    elif view == \"-XY\":\n        self.camera.show_object(\n            self.scene, view_dir=(0.0, 0.0, -1.0), up=(0.0, -1.0, 0.0)\n        )\n    elif view == \"XZ\":\n        self.camera.show_object(\n            self.scene, scale=1, view_dir=(0.0, 1.0, 0.0), up=(0.0, 0.0, 1.0)\n        )\n    elif view == \"-XZ\":\n        self.camera.show_object(\n            self.scene, scale=1, view_dir=(0.0, -1.0, 0.0), up=(0.0, 0.0, 1.0)\n        )\n    elif view == \"YZ\":\n        self.camera.show_object(\n            self.scene, scale=1, view_dir=(1.0, 0.0, 0.0), up=(0.0, -1.0, 0.0)\n        )\n    elif view == \"YZ\":\n        self.camera.show_object(\n            self.scene, scale=1, view_dir=(-1.0, 0.0, 0.0), up=(0.0, -1.0, 0.0)\n        )\n    elif isinstance(view, dict):\n        self.camera.set_state(view)\n    else:\n        raise TypeError(f\"Unable to set view from {type(view)}\")\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.show","title":"<code>show(use_sidecar=False, toolbar=False, start_loop=False)</code>","text":"<p>Show viewer.</p> PARAMETER DESCRIPTION <code>For</code> <p> </p> <code>use_sidecar</code> <pre><code>      If True, will use the Sidecar extension to display the\n      viewer outside the notebooks. Will throw an error if\n      Sidecar is not installed.\n</code></pre> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>toolbar</code> <pre><code>      If True, will show a toolbar. You can always show/hide\n      the toolbar with ``viewer.show_controls()`` and\n      ``viewer.hide_controls()``, or the `c` hotkey.\n</code></pre> <p> TYPE: <code>    bool</code> DEFAULT: <code>False</code> </p> <code>For</code> <p> </p> <code>start_loop</code> <pre><code>      If True, will start the blocking (!) event loop. This is\n      the recommended way to show the viewer when using it in a script.\n      From an interactive REPL such as IPython you should be able to\n      just call ``Viewer.show()`` and the interactive viewer will appear\n      while still allowing you to interact with the REPL.\n</code></pre> <p> TYPE: <code> bool</code> DEFAULT: <code>False</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def show(self, use_sidecar=False, toolbar=False, start_loop=False):\n    \"\"\"Show viewer.\n\n    Parameters\n    ----------\n\n    For Jupyter lab only:\n\n    use_sidecar : bool\n                  If True, will use the Sidecar extension to display the\n                  viewer outside the notebooks. Will throw an error if\n                  Sidecar is not installed.\n    toolbar :     bool\n                  If True, will show a toolbar. You can always show/hide\n                  the toolbar with ``viewer.show_controls()`` and\n                  ``viewer.hide_controls()``, or the `c` hotkey.\n\n    For scripts &amp; standard REPL:\n\n    start_loop :  bool\n                  If True, will start the blocking (!) event loop. This is\n                  the recommended way to show the viewer when using it in a script.\n                  From an interactive REPL such as IPython you should be able to\n                  just call ``Viewer.show()`` and the interactive viewer will appear\n                  while still allowing you to interact with the REPL.\n\n    \"\"\"\n    # This is for e.g. headless testing\n    if getattr(config, \"HEADLESS\", False):\n        logger.info(\"Viewer widget not shown - running in headless mode.\")\n        return\n\n    # Start the animation loop\n    self.canvas.request_draw(self._animate)\n\n    # If this is an offscreen canvas, we don't need to do anything else\n    if isinstance(self.canvas, OffscreenRenderCanvas):\n        return\n\n    # In terminal we can just show the window\n    if not self._is_jupyter:\n        # Not all backends have a show method (e.g. GLFW does not)\n        if hasattr(self.canvas, \"show\"):\n            self.canvas.show()\n\n        if start_loop:\n            from rendercanvas.auto import loop\n\n            loop.run()\n        elif utils._type_of_script() in (\"terminal\", \"script\"):\n            logger.warning(\n                \"Running in a (potentially) non-interactive terminal or script \"\n                \"environment. You may have to manually start the event loop \"\n                \"for the canvas to render:\\n\\n\"\n                \"  &gt;&gt;&gt; v = octarine.Viewer(show=False)\\n\"\n                \"  &gt;&gt;&gt; ...  # setup your viewer\\n\"\n                \"  &gt;&gt;&gt; v.show(start_loop=True)\\n\\n\"\n                \"Alternatively, use the loop.run() function:\\n\\n\"\n                \"  &gt;&gt;&gt; from rendercanvas.auto import loop\\n\"\n                \"  &gt;&gt;&gt; ...  # setup your viewer\\n\"\n                \"  &gt;&gt;&gt; v.show()\\n\"\n                \"  &gt;&gt;&gt; loop.run()\\n\\n\"  # do not remove the \\n\\n here\n            )\n    else:\n        # if not hasattr(self, 'widget'):\n        from .jupyter import JupyterOutput\n        from IPython.display import display\n\n        # Construct the widget\n        if not hasattr(self, \"widget\"):\n            self.widget = JupyterOutput(\n                self,\n                use_sidecar=use_sidecar,\n                toolbar=toolbar,\n                sidecar_kwargs={\"title\": self._title},\n            )\n\n        # This will display the viewer right here and there\n        display(self.widget)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.show_controls","title":"<code>show_controls()</code>","text":"<p>Show controls.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def show_controls(self):\n    \"\"\"Show controls.\"\"\"\n    if self._is_jupyter:\n        if self.widget.toolbar:\n            self.widget.toolbar.show()\n    else:\n        if not hasattr(self, \"_controls\"):\n            from .controls import Controls\n\n            self._controls = Controls(self)\n        self._controls.show()\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.show_message","title":"<code>show_message(message, position='top-right', font_size=20, color=None, duration=None)</code>","text":"<p>Show message on canvas.</p> PARAMETER DESCRIPTION <code>message</code> <pre><code>    Message to show. Set to `None` to remove the existing message.\n</code></pre> <p> TYPE: <code>  str | None</code> </p> <code>position</code> <pre><code>    Position of the message on the canvas.\n</code></pre> <p> TYPE: <code> \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\" | \"center\"</code> DEFAULT: <code>'top-right'</code> </p> <code>font_size</code> <pre><code>    Font size of the message.\n</code></pre> <p> TYPE: <code>int</code> DEFAULT: <code>20</code> </p> <code>color</code> <pre><code>    Color of the message. If `None`, will use white.\n</code></pre> <p> TYPE: <code>    str | tuple</code> DEFAULT: <code>None</code> </p> <code>duration</code> <pre><code>    Number of seconds after which to fade the message.\n</code></pre> <p> TYPE: <code> int</code> DEFAULT: <code>None</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>def show_message(\n    self, message, position=\"top-right\", font_size=20, color=None, duration=None\n):\n    \"\"\"Show message on canvas.\n\n    Parameters\n    ----------\n    message :   str | None\n                Message to show. Set to `None` to remove the existing message.\n    position :  \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\" | \"center\"\n                Position of the message on the canvas.\n    font_size : int, optional\n                Font size of the message.\n    color :     str | tuple, optional\n                Color of the message. If `None`, will use white.\n    duration :  int, optional\n                Number of seconds after which to fade the message.\n\n    \"\"\"\n    if message is None and hasattr(self, \"_message_text\"):\n        if self._message_text.parent:\n            self.overlay_scene.remove(self._message_text)\n        del self._message_text\n        return\n\n    _positions = {\n        \"top-left\": (-0.95, 0.95, 0),\n        \"top-right\": (0.95, 0.95, 0),\n        \"bottom-left\": (-0.95, -0.95, 0),\n        \"bottom-right\": (0.95, -0.95, 0),\n        \"center\": (0, 0, 0),\n    }\n    if position not in _positions:\n        raise ValueError(f\"Unknown position: {position}\")\n\n    if not hasattr(self, \"_message_text\"):\n        self._message_text = text2gfx(\n            message, color=\"white\", font_size=font_size, screen_space=True\n        )\n\n    # Make sure the text is in the scene\n    if self._message_text not in self.overlay_scene.children:\n        self.overlay_scene.add(self._message_text)\n\n    self._message_text.set_text(message)\n    self._message_text.font_size = font_size\n    self._message_text.anchor = position\n    if color is not None:\n        self._message_text.material.color = cmap.Color(color).rgba\n    self._message_text.material.opacity = 1\n    self._message_text.local.position = _positions[position]\n\n    # When do we need to start fading out?\n    if duration:\n        self._fade_out_time = time.time() + duration\n\n        def _fade_message():\n            if not hasattr(self, \"_message_text\"):\n                self.remove_animation(_fade_message)\n            else:\n                if time.time() &gt; self._fade_out_time:\n                    # This means the text will fade fade over 1/0.02 = 50 frames\n                    self._message_text.material.opacity = max(\n                        self._message_text.material.opacity - 0.02, 0\n                    )\n\n                if self._message_text.material.opacity &lt;= 0:\n                    if self._message_text.parent:\n                        self.overlay_scene.remove(self._message_text)\n                    self.remove_animation(_fade_message)\n\n        self.add_animation(_fade_message)\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.toggle_bounds","title":"<code>toggle_bounds()</code>","text":"<p>Toggle bounding box.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def toggle_bounds(self):\n    \"\"\"Toggle bounding box.\"\"\"\n    self.show_bounds = not self.show_bounds\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.unhide_objects","title":"<code>unhide_objects(obj=None)</code>","text":"<p>Unhide given object(s).</p> PARAMETER DESCRIPTION <code>obj</code> <pre><code>Object(s) to unhide. If None, will unhide all objects.\n</code></pre> <p> TYPE: <code>  str | list | None</code> DEFAULT: <code>None</code> </p> Source code in <code>octarine/viewer.py</code> <pre><code>@update_viewer(legend=True, bounds=True)\ndef unhide_objects(self, obj=None):\n    \"\"\"Unhide given object(s).\n\n    Parameters\n    ----------\n    obj :   str | list | None\n            Object(s) to unhide. If None, will unhide all objects.\n\n    \"\"\"\n    objects = self.objects  # grab once to speed things up\n    if obj is not None:\n        ids = utils.make_iterable(obj)\n    else:\n        ids = list(objects.keys())\n\n    for ob in ids:\n        if ob not in objects:\n            logger.warning(f\"Object {ob} not found on canvas.\")\n            continue\n        for v in objects[ob]:\n            if getattr(v, \"_pinned\", False):\n                continue\n            if not v.visible:\n                v.visible = True\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.unhighlight_objects","title":"<code>unhighlight_objects(obj=None)</code>","text":"<p>Unhighlight given object(s).</p> PARAMETER DESCRIPTION <code>obj</code> <pre><code>Object(s) to unhighlight. Can be the name(s) or ID(s) of\nthe object(s), their index(es) in the list of visuals,\nor the visual(s) themselves. If None, will unhighlight all\nobjects. Objects that aren't highlighted will be silently\nignored.\n</code></pre> <p> TYPE: <code>  str | int | list | visual</code> DEFAULT: <code>None</code> </p> See Also <p>Viewer.highlight_objects         Use to highlight objects</p> Source code in <code>octarine/viewer.py</code> <pre><code>def unhighlight_objects(self, obj=None):\n    \"\"\"Unhighlight given object(s).\n\n    Parameters\n    ----------\n    obj :   str | int | list | visual\n            Object(s) to unhighlight. Can be the name(s) or ID(s) of\n            the object(s), their index(es) in the list of visuals,\n            or the visual(s) themselves. If None, will unhighlight all\n            objects. Objects that aren't highlighted will be silently\n            ignored.\n\n    See Also\n    --------\n    Viewer.highlight_objects\n            Use to highlight objects\n\n    \"\"\"\n    # Important note: it looks like any attribute we added previously\n    # will (at some point) have been silently renamed to \"_Viewer{attribute}\"\n    if obj is None:\n        obj = [v for v in self.visuals if getattr(v, \"_highlighted\", False)]\n\n    if not utils.is_iterable(obj):\n        objects = [obj]\n    else:\n        objects = obj\n\n    all_objects = self.objects  # grab once to speed things up\n\n    for ob in objects:\n        if ob in all_objects:\n            list_ = all_objects[ob]\n        elif isinstance(ob, int):\n            list_ = list(self.visuals.values())[ob]\n        elif isinstance(ob, gfx.WorldObject):\n            list_ = [ob]\n        else:\n            raise TypeError(f\"Unknown object type: {type(ob)}\")\n\n        for o in list_:\n            # Skip if object is pinned\n            if getattr(o, \"_pinned\", False):\n                continue\n\n            # Skip if object isn't actually highlighed\n            if not getattr(o, \"_highlighted\", False):\n                continue\n            o.material.color = o.material._original_color\n            del o.material._original_color\n            del o._highlighted\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.unpin_objects","title":"<code>unpin_objects(obj=None)</code>","text":"<p>Unpin given object(s).</p> <p>Use <code>obj</code> to unhide specific neurons.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def unpin_objects(self, obj=None):\n    \"\"\"Unpin given object(s).\n\n    Use ``obj`` to unhide specific neurons.\n\n    \"\"\"\n    objects = self.objects  # grab once to speed things up\n    if obj is None:\n        obj = objects\n    else:\n        obj = utils.make_iterable(obj)\n\n    for ob in obj:\n        if ob not in objects:\n            logger.warning(f\"Object {ob} not found on canvas.\")\n            continue\n        for v in objects[ob]:\n            v._pinned = False\n</code></pre>"},{"location":"api/viewer/#octarine.Viewer.update_bounds","title":"<code>update_bounds(color='w', width=1)</code>","text":"<p>Update bounding box visual.</p> Source code in <code>octarine/viewer.py</code> <pre><code>def update_bounds(self, color=\"w\", width=1):\n    \"\"\"Update bounding box visual.\"\"\"\n    # Remove any existing visual\n    self.remove_bounds()\n\n    self._show_bounds = True\n\n    # Skip if no visual on canvas\n    bounds = self.scene.get_bounding_box()\n    if isinstance(bounds, type(None)):\n        return\n\n    # Create box visual\n    box = gfx.BoxHelper()\n    box.set_transform_by_aabb(bounds)\n\n    # Add custom attributes\n    box._object_type = \"boundingbox\"\n    box._object_id = uuid.uuid4()\n\n    self.scene.add(box)\n</code></pre>"},{"location":"extending/","title":"Extending Octarine","text":""},{"location":"extending/#extending-octarine","title":"Extending <code>Octarine</code>","text":"<p>In Adding Objects you learned how to use the built-in object types. But what if you have want to visualize something not currently supported by <code>Octarine</code>?</p> <p>You have effectively two options:</p> <p>Option 1 is to generate the <code>pygfx</code> visual (e.g. a <code>pygfx.Mesh</code> or a <code>pygfx.Line</code>) yourself and use the generic octarine.Viewer.add<code>()</code> method to add them to the scene.</p> <p>The above is good enough for the odd one-off but what if you want to use the <code>Octarine</code> viewer for your specialised data on a regular basis? Easy: you extend <code>Octarine</code>'s functionality to include your data!</p> <p>Option 2 is to write Custom Converter functions for your data and register them with <code>Octarine</code>. You can then package these converters as Plugins</p>"},{"location":"extending/converters/","title":"Custom Converters","text":""},{"location":"extending/converters/#custom-converters","title":"Custom Converters","text":"<p><code>Octarine</code> knows off the bat how to convert various data types to <code>pygfx</code> visuals. When you throw data at e.g. <code>Viewer.add</code>, <code>Octarine</code> searches a set of known converter functions and tries to find one that fits the bill. If it can't find a matching converter it will complain.</p> <p>In this tutorial you will learn how to generate and register new converter functions. See the Plugins tutorial on how to package these into a separate package.</p> <p>First we will define a dummy class for our \"custom data\":</p> <pre><code>class Point3d:\n    \"\"\"Class representing a single 3d point.\"\"\"\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n</code></pre> <p>Next, we need to write a function that converts a <code>Point3d</code> into a <code>pygfx</code> object:</p> <pre><code>import pygfx as gfx\n\ndef convert_point3d(point, radius=1, color='red'):\n    \"\"\"Convert a Point3d to a pygfx Sphere.\"\"\"\n    assert isinstance(point, Point3d)\n\n    # The geometry\n    geometry = gfx.geometries.sphere_geometry(radius=radius)\n\n    # The material\n    material = gfx.MeshPhongMaterial(color=color)\n\n    # Combine\n    mesh = gfx.Mesh(geometry, material)\n\n    # Set coordinates\n    mesh.local.position = (point.x, point.y, point.z)\n\n    # Return the mesh\n    return [mesh]\n</code></pre> <p>Now that we have a function that converts from <code>Point3d</code> to a <code>pygfx</code> visual, we need to tell <code>Octarine</code> about it:</p> <pre><code>import octarine as oc\n\noc.register_converter(Point3d, convert_point3d)\n</code></pre> <p>With that we add a <code>Point3d</code> to any viewer:</p> <pre><code>p = Point3d(1, 1, 1)\n\nv = oc.Viewer()\nv.add(p)\n</code></pre> <p></p> <p>If you like can even add a specialized <code>.add_...()</code> method:</p> <pre><code>@oc.viewer.update_viewer\ndef add_point3d(self, point, name=None, color=None, radius=1, center=True):\n    \"\"\"Add Point3d to canvas.\n\n    Parameters\n    ----------\n    point :     Point3D\n                Point to plot.\n    name :      str, optional\n                Name for the visual.\n    color :     str | tuple, optional\n                Color to use for the visual.\n    center :    bool, optional\n                If True, re-center camera to all objects on canvas.\n\n    \"\"\"\n    # This grabs the next available color\n    if color is None:\n        color = self._next_color()\n    # Make sure we have a sensible name for our visual\n    if name is None:\n        name = self._next_label('Point')\n    elif not isinstance(name, str):\n        name = str(name)\n\n    visual = convert_point3d(point, color=color, radius=radius)\n    visual._object_id = name if name else uuid.uuid4()\n    self.scene.add(visual)\n\n    if center:\n        self.center_camera()\n\n# Monkey patch the Viewer\noc.Viewer.add_point3d = add_point3d\n</code></pre> <p>Now this should work:</p> <pre><code>&gt;&gt;&gt; p = Point3d(1, 1, 1)\n&gt;&gt;&gt; v = oc.Viewer()\n&gt;&gt;&gt; v.add_point3d(p)\n</code></pre> <p>OK, now you know how to write a custom converter. You could run the above code every time you start a new Python session but that gets old pretty quickly.</p> <p>The more permanent solution is to write a Plugin that can be installed and is imported alongside <code>Octarine</code>.</p>"},{"location":"extending/plugins/","title":"Plugins","text":""},{"location":"extending/plugins/#plugins","title":"Plugins","text":"<p>In the Custom Converters tutorial you learned how to generate and register new converter functions. Here we will show you how to package converters into installable plugins for <code>Octarine</code>.</p> <p>By convention, <code>Octarine</code> plugins are called <code>octarine-{name}-plugin</code>. Here, we will generate an example plugin for the <code>Point3d</code> dummy class we used to illustrate converters.</p>"},{"location":"extending/plugins/#project-layout","title":"Project layout","text":"<p>Just to orient you, this is the structure of our example plugins - a bog-standard Python project:</p> <pre><code>.\n\u251c\u2500\u2500 octarine_point3d_plugin\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 converters.py\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"extending/plugins/#adding-functionality","title":"Adding functionality","text":"<p>First we need to define a registration function to add new functionality to <code>Octarine</code>. Here, we will do so directly in the <code>__init__.py</code> but you can also define it elsewhere and import it at top-level of the namespace.</p> <pre><code># __init__.py\n\nimport octarine as oc\n\n# Import converters (see the \"Custom Converters\" Tutorial for details)\nfrom .converters import convert_point3d, add_point3d\n\n\ndef register_plugin():\n    \"\"\"Register Point3d converter and method with Octarine.\"\"\"\n    # Register the new converter\n    oc.register_converter(Point3d, convert_point3d)\n\n    # Monkey-patch the Viewer class\n    oc.Viewer.add_point3d = add_point3d\n</code></pre> <p>Note</p> <p>Consider delaying imports for large (read: slow to import) libraries until you actually need them. For example by putting the <code>import</code> statements inside the converter functions. That way <code>Octarine</code> itself will not be bogged down by the plugin and remain quick to import.</p>"},{"location":"extending/plugins/#entry-point","title":"Entry Point","text":"<p>Next we need to make <code>Octarine</code> aware of the new plugin. For that we are using <code>setuptools</code>' entry points and is as simple as modifying the call to <code>setup()</code> in the <code>setup.py</code>:</p> <pre><code># setup.py\nfrom setuptools import setup\n\n...\n\nsetup(\n    name=\"octarine-point3d-plugin\",\n    ...\n    entry_points={\n        \"octarine.plugins\": [\n            \"octarine_point3d_plugin = octarine_point3d_plugin:register_plugin\",\n        ]\n    },\n)\n</code></pre> <p>The important thing here is that we define an entry point for <code>octarine.plugins</code> which makes the plugin discoverable by <code>Octarine</code>. The entry point itself then tells us which module to import (<code>octarine_point3d_plugin</code>) and which function (<code>octarine_point3d_plugin:register_plugin</code>) to run in order to teach <code>Octarine</code> how to deal with new data. It is not enforced but by convention that function should be called <code>register_plugin()</code>.</p> <p>And that's it! Publish the plugin to PyPI and everyone who installs it will be able to use <code>Point3d</code> with <code>Octarine</code>.</p>"},{"location":"extending/plugins/#concluding-remarks","title":"Concluding Remarks","text":"<p>The plugin system is currently rather simple but you can still do a lot with it - in particular if you use monkey patching to modify the behavior of the <code>Viewer</code> class.</p> <p>See <code>octarine-navis-plugin</code> for an example of an <code>Octarine</code> plugin in the wild.</p>"}]}